// Combined Script Export
// Generated on: 2025-08-25 09:30:19
// Total files: 34
// ============================================================

// FILE: AIController.cs
// PATH: Assets/Scripts/AI/AIController.cs
// ----------------------------------------

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Chess2D.Events;
using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.AI
{
    public class AIController : MonoBehaviour
    {
        [SerializeField] private GameEvents _gameEvents;
        [Range(1, 3)][SerializeField] private int _depth = 1;
        private Board.IBoard _board;
        private CancellationTokenSource _cts;

        private void OnEnable()
        {
            _gameEvents.SwitchTurnToAIEvent.OnEventRaised += MakeAIMove;
            _gameEvents.SwitchTurnToPlayerEvent.OnEventRaised += CancelMove;
        }

        private void OnDisable()
        {
            _gameEvents.SwitchTurnToAIEvent.OnEventRaised -= MakeAIMove;
            _gameEvents.SwitchTurnToPlayerEvent.OnEventRaised -= CancelMove;
        }

        private void Start() => _board = GameManager.Instance.Board;

        private void CancelMove(Empty e) => _cts?.Cancel();

        private async void MakeAIMove(Empty empty = null)
        {
            _cts = new CancellationTokenSource();

            Move bestMove = null;
            try
            {
                bestMove = await Task.Run(() =>
                    GetBestMove(_depth, float.NegativeInfinity, float.PositiveInfinity, true, _cts.Token),
                    _cts.Token
                );
            }
            catch (OperationCanceledException)
            {
                Debug.Log("AI move canceled due to time out.");
                return;
            }

            if (bestMove != null)
                ExecuteMove(bestMove);
        }

        private Move GetBestMove(int depth, float alpha, float beta, bool maximizingPlayer, CancellationToken token)
        {
            token.ThrowIfCancellationRequested();
            List<Move> allMoves = GetAllPossibleMoves(false);

            Move bestMove = null;
            float bestEval = maximizingPlayer ? float.NegativeInfinity : float.PositiveInfinity;

            foreach (var move in allMoves)
            {
                token.ThrowIfCancellationRequested();
                
                var captured = SimulateMove(move);

                float eval = Minimax(depth - 1, alpha, beta, !maximizingPlayer);

                UndoMove(move, captured);

                if (maximizingPlayer)
                {
                    if (eval > bestEval)
                    {
                        bestEval = eval;
                        bestMove = move;
                    }
                    alpha = Mathf.Max(alpha, eval);
                }
                else
                {
                    if (eval < bestEval)
                    {
                        bestEval = eval;
                        bestMove = move;
                    }
                    beta = Mathf.Min(beta, eval);
                }

                if (beta <= alpha)
                    break;
            }

            return bestMove;
        }

        private float Minimax(int depth, float alpha, float beta, bool maximizingPlayer)
        {
            if (depth == 0)
                return EvaluateBoard();

            List<Move> moves = GetAllPossibleMoves(!maximizingPlayer);

            float bestEval = maximizingPlayer ? float.NegativeInfinity : float.PositiveInfinity;

            foreach (var move in moves)
            {
                var captured = SimulateMove(move);

                float eval = Minimax(depth - 1, alpha, beta, !maximizingPlayer);

                UndoMove(move, captured);

                if (maximizingPlayer)
                {
                    bestEval = Mathf.Max(bestEval, eval);
                    alpha = Mathf.Max(alpha, eval);
                }
                else
                {
                    bestEval = Mathf.Min(bestEval, eval);
                    beta = Mathf.Min(beta, eval);
                }

                if (beta <= alpha)
                    break;
            }

            return bestEval;
        }

        private float EvaluateBoard()
        {
            float eval = 0f;

            for (int row = 0; row < 8; row++)
            {
                for (int col = 0; col < 8; col++)
                {
                    if (!_board.TryGetOccupiedPieceAt(new Vector2Int(col, row), out var piece)) continue;

                    float value = GetPieceValue(piece.PieceData.Type);
                    eval += piece.PieceData.IsPlayer ? -value : value;
                }
            }

            return eval;
        }

        private float GetPieceValue(PieceType type) => type switch
        {
            PieceType.Pawn => 1f,
            PieceType.Knight => 4f,
            PieceType.Bishop => 3f,
            PieceType.Rook => 5f,
            PieceType.Queen => 9f,
            PieceType.King => 100f,
            _ => 0f
        };

        private List<Move> GetAllPossibleMoves(bool isPlayer)
        {
            List<Move> moves = new();

            for (int row = 0; row < 8; row++)
            {
                for (int col = 0; col < 8; col++)
                {
                    if (!_board.TryGetOccupiedPieceAt(new Vector2Int(col, row), out var piece)) continue;

                    if (piece.PieceData.IsPlayer == isPlayer)
                    {
                        Vector2Int current = new(col, row);

                        piece.MoveStrategy.CalculateLegalMoves(isPlayer, current, to =>
                        {
                            moves.Add(new Move
                            {
                                from = current,
                                to = to,
                                movedPiece = piece,
                                ContainsCapturablePiece = _board.ContainsOpponentPieceAt(to, isPlayer)
                            });
                        });
                    }
                }
            }

            return moves;
        }

        private ChessPiece SimulateMove(Move move)
        {
            ChessPiece captured = _board.GetOccupiedPieceAt(move.to);

            _board.SetOccupiedPieceAt(null, move.from);
            _board.SetOccupiedPieceAt(move.movedPiece, move.to);

            return captured;
        }

        private void UndoMove(Move move, ChessPiece captured)
        {
            _board.SetOccupiedPieceAt(null, move.to);
            _board.SetOccupiedPieceAt(move.movedPiece, move.from);

            if (captured != null)
                _board.SetOccupiedPieceAt(captured, move.to);
        }

        private void ExecuteMove(Move move)
        {
            move.movedPiece.SetPiecePosition(move.to);

            if (move.ContainsCapturablePiece && _board.TryCapturePieceAt(move.to, false, out var capturedPiece))
            {
                if (capturedPiece != null)
                    _gameEvents.PieceCaptureEvent.RaiseEvent(capturedPiece);

                if (capturedPiece.PieceType == PieceType.King)
                    _gameEvents.WinEvent.RaiseEvent(null);
            }

            _board.SetOccupiedPieceAt(null, move.from);
            _board.SetOccupiedPieceAt(move.movedPiece, move.to);

            _gameEvents.AIMadeMoveEvent.RaiseEvent(move.to);
        }
    }
}

// ----------------------------------------

// FILE: Move.cs
// PATH: Assets/Scripts/AI/Move.cs
// ----------------------------------------

using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.AI
{
    public class Move
    {
        public Vector2Int from;
        public Vector2Int to;
        public ChessPiece movedPiece;
        public bool ContainsCapturablePiece;
    }
}

// ----------------------------------------

// FILE: AudioManager.cs
// PATH: Assets/Scripts/Audio/AudioManager.cs
// ----------------------------------------

using System;
using Chess2D.Events;
using UnityEngine;

namespace Chess2D.Audio
{
    public class AudioManager : MonoBehaviour
    {
        [SerializeField] private GameEvents _gameEvents;
        [SerializeField] private AudioSource _sfxAudioSource;
        [SerializeField] private AudioSource _musicAudioSource;

        private void OnEnable()
        {
            _gameEvents.PlayOneShotAudio.OnEventRaised += PlaySFX;
        }

        private void OnDisable()
        {
            _gameEvents.PlayOneShotAudio.OnEventRaised -= PlaySFX;
        }

        public void ToggleMusic(bool isOn)
        {
            if (isOn)
                _musicAudioSource.Play();
            else
                _musicAudioSource.Stop();
        }

        public void ToggleSFX(bool isOn)
        {
            if (isOn)
                _sfxAudioSource.Play();
            else
                _sfxAudioSource.Stop();
        }

        private void PlaySFX(AudioClip sfx) => _sfxAudioSource.PlayOneShot(sfx);
    }
}

// ----------------------------------------

// FILE: BoardUtilities.cs
// PATH: Assets/Scripts/Board/Utilities/BoardUtilities.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Board.Utilities
{
    public static class BoardUtilities
    {
        public static bool IsWithinBoard(Vector2Int tile) => tile.x < 8 && tile.x >= 0 && tile.y < 8 && tile.y >= 0;
    }
}

// ----------------------------------------

// FILE: ChessBoard.cs
// PATH: Assets/Scripts/Board/ChessBoard.cs
// ----------------------------------------

using Chess2D.Events;
using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.Board
{
    public interface IBoardQuery
    {
        bool IsTileEmptyAt(Vector2Int boardPosition);
        bool ContainsAllyPieceAt(Vector2Int boardPosition, bool isPlayer);
        bool ContainsOpponentPieceAt(Vector2Int boardPosition, bool isPlayer);
        bool TryGetOccupiedPieceAt(Vector2Int boardPosition, out ChessPiece occupiedPiece);
        ChessPiece GetOccupiedPieceAt(Vector2Int boardPosition);
        bool TryGetPlayerPieceAt(Vector2Int boardPosition, out ChessPiece playerPiece);
    }

    public interface IBoardCommand
    {
        void SetOccupiedPieceAt(ChessPiece occupiedPiece, Vector2Int boardPosition);
        bool TryCapturePieceAt(Vector2Int boardPosition, bool isPlayerPieceSelected, out ChessPiece capturedPiece);
    }

    public interface IBoard : IBoardQuery, IBoardCommand { }

    public class ChessBoard : IBoard
    {
        private const int BOARD_SIZE = 8;
        private readonly ChessPiece[,] _pieceGrid = new ChessPiece[BOARD_SIZE, BOARD_SIZE];
        private readonly EventChannel<ChessPiece> _onIntializeChessPieceEvent = default;

        public ChessBoard(EventChannel<ChessPiece> onIntializeChessPieceEvent)
        {
            _onIntializeChessPieceEvent = onIntializeChessPieceEvent;
        }

        public void InitializeBoard(MoveStrategyFactory moveStrategyFactory, PieceFactory<PieceRenderer> playerPieceFactory, PieceFactory<PieceRenderer> aiPieceFactory, Transform playerPieceTransform, Transform aiPieceTransform)
        {
            int playerBackRow = 0;
            int playerFrontRow = 1;
            int aiBackRow = 7;
            int aiFrontRow = 6;

            PieceType[] backRowSetup =
            {
                PieceType.Rook, PieceType.Knight, PieceType.Bishop,
                PieceType.Queen, PieceType.King, PieceType.Bishop,
                PieceType.Knight, PieceType.Rook
            };

            for (int col = 0; col < BOARD_SIZE; col++)
            {
                // Pawns
                CreateAndPlacePiece(moveStrategyFactory, playerPieceFactory, new PieceData(PieceType.Pawn, true), new Vector2Int(col, playerFrontRow), playerPieceTransform);
                CreateAndPlacePiece(moveStrategyFactory, aiPieceFactory, new PieceData(PieceType.Pawn, false), new Vector2Int(col, aiFrontRow), aiPieceTransform);

                // Back row pieces
                CreateAndPlacePiece(moveStrategyFactory, playerPieceFactory, new PieceData(backRowSetup[col], true), new Vector2Int(col, playerBackRow), playerPieceTransform);
                CreateAndPlacePiece(moveStrategyFactory, aiPieceFactory, new PieceData(backRowSetup[col], false), new Vector2Int(col, aiBackRow), aiPieceTransform);
            }
        }

        private void CreateAndPlacePiece(MoveStrategyFactory moveStrategyFactory, PieceFactory<PieceRenderer> pieceFactory, PieceData pieceData, Vector2Int gridIndex, Transform container)
        {
            PieceRenderer pieceRenderer = pieceFactory.GetPiece(pieceData.Type);

            ChessPiece piece = new(moveStrategyFactory.GetPieceMoveStrategy(pieceData), pieceData, pieceRenderer);

            piece.SetPiecePosition(gridIndex);
            piece.Transform.SetParent(container);

            _pieceGrid[gridIndex.y, gridIndex.x] = piece;

            _onIntializeChessPieceEvent.RaiseEvent(piece);
        }

        public bool TryGetPlayerPieceAt(Vector2Int boardPosition, out ChessPiece playerPiece)
        {
            playerPiece = _pieceGrid[boardPosition.y, boardPosition.x];

            return playerPiece != null && playerPiece.IsPlayer == true;
        }

        public bool IsTileEmptyAt(Vector2Int boardPosition) => _pieceGrid[boardPosition.y, boardPosition.x] == null;
        public bool ContainsOpponentPieceAt(Vector2Int boardPosition, bool isPlayerPieceSelected) => !IsTileEmptyAt(boardPosition) && _pieceGrid[boardPosition.y, boardPosition.x].IsPlayer ^ isPlayerPieceSelected;

        public bool ContainsAllyPieceAt(Vector2Int boardPosition, bool isPlayerPieceSelected) => !IsTileEmptyAt(boardPosition) && _pieceGrid[boardPosition.y, boardPosition.x].IsPlayer == isPlayerPieceSelected;

        public void SetOccupiedPieceAt(ChessPiece occupiedPiece, Vector2Int boardPosition) => _pieceGrid[boardPosition.y, boardPosition.x] = occupiedPiece;

        public bool TryCapturePieceAt(Vector2Int boardPosition, bool isPlayerPieceSelected, out ChessPiece capturedPiece)
        {
            capturedPiece = null;

            if (ContainsOpponentPieceAt(boardPosition, isPlayerPieceSelected))
            {
                capturedPiece = _pieceGrid[boardPosition.y, boardPosition.x];

                CapturePieceAt(boardPosition, capturedPiece);
            }

            return capturedPiece != null;
        }

        private void CapturePieceAt(Vector2Int boardPosition, ChessPiece chessPiece)
        {
            if (chessPiece != null)
            {
                chessPiece.SetInActive();
                SetOccupiedPieceAt(null, boardPosition);
            }
        }

        public bool TryGetOccupiedPieceAt(Vector2Int boardPosition, out ChessPiece occupiedPiece)
        {
            occupiedPiece = _pieceGrid[boardPosition.y, boardPosition.x];

            return occupiedPiece != null;
        }

        public ChessPiece GetOccupiedPieceAt(Vector2Int boardPosition) => _pieceGrid[boardPosition.y, boardPosition.x];
    }
}

// ----------------------------------------

// FILE: ChessPiece.cs
// PATH: Assets/Scripts/ChessPieces/ChessPiece.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Piece
{
    public class ChessPiece
    {
        private readonly PieceRenderer _pieceRenderer;
        public IMoveStrategy MoveStrategy { get; private set; }
        public PieceData PieceData { get; }
        public bool IsPlayer => PieceData.IsPlayer;
        public PieceType PieceType => PieceData.Type;
        public Transform Transform => _pieceRenderer.transform;
        public Vector2Int BoardPosition => new(
            (int)_pieceRenderer.transform.position.x,
            (int)_pieceRenderer.transform.position.y);

        public ChessPiece(
            IMoveStrategy moveStrategy,
            PieceData pieceData,
            PieceRenderer pieceRenderer)
        {
            PieceData = pieceData;
            _pieceRenderer = pieceRenderer;

            MoveStrategy = moveStrategy;
        }

        public void SetMoveStrategy(IMoveStrategy moveStrategy) => MoveStrategy = moveStrategy;
        public void SetPiecePosition(Vector2Int position) => _pieceRenderer.SetWorldPosition(new Vector3Int(position.x, position.y));
        public void SetInActive() => _pieceRenderer.SetInActive();
        public void SetActive() => _pieceRenderer.SetActive();
    }
}

// ----------------------------------------

// FILE: ChessPieceDatabase.cs
// PATH: Assets/Scripts/ChessPieces/ChessPieceDatabase.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Piece
{
    public class ChessPieceDatabase<T> : ScriptableObject where T : Object
    {
        [field: SerializeField] public PieceSet<T> WhitePieceSet { get; private set; }
        [field: SerializeField] public PieceSet<T> BlackPieceSet { get; private set; }
    }
}

// ----------------------------------------

// FILE: Directions.cs
// PATH: Assets/Scripts/ChessPieces/Directions.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Piece
{
    public static class Directions
    {
        public static readonly Vector2Int Up = Vector2Int.up;
        public static readonly Vector2Int Down = Vector2Int.down;
        public static readonly Vector2Int Left = Vector2Int.left;
        public static readonly Vector2Int Right = Vector2Int.right;

        public static readonly Vector2Int UpLeft = Vector2Int.up + Vector2Int.left;
        public static readonly Vector2Int UpRight = Vector2Int.up + Vector2Int.right;
        public static readonly Vector2Int DownLeft = Vector2Int.down + Vector2Int.left;
        public static readonly Vector2Int DownRight = Vector2Int.down + Vector2Int.right;

        public static readonly Vector2Int[] Diagonals =
        {
            UpLeft, UpRight, DownLeft, DownRight
        };

        public static readonly Vector2Int[] Orthogonals =
        {
            Up, Down, Left, Right
        };

        public static readonly Vector2Int[] EightDirections =
        {
            UpLeft, UpRight, DownLeft, DownRight,
            Up, Down, Left, Right
        };

        public static readonly Vector2Int[] KnightMoves =
        {
            new(1, 2), new(2, 1),
            new(2, -1), new(1, -2),
            new(-1, -2), new(-2, -1),
            new(-2, 1), new(-1, 2)
        };

        public static readonly Vector2Int[] KingMoves = EightDirections;
    }
}

// ----------------------------------------

// FILE: IMoveStrategy.cs
// PATH: Assets/Scripts/ChessPieces/IMoveStrategy.cs
// ----------------------------------------

using System;
using Chess2D.Board;
using Chess2D.Board.Utilities;
using UnityEngine;

namespace Chess2D.Piece
{
    public interface IMoveStrategy
    {
        void CalculateLegalMoves(
            bool isPlayerPieceSelected,
            Vector2Int currentTile,
            Action<Vector2Int> onGetLegalMoveAction);
    }

    public interface IMoveStrategySwitch
    {
        void SwitchStrategy();
    }

    public class PawnMove : IMoveStrategy, IMoveStrategySwitch
    {
        private readonly IMoveStrategy _nonCaptureSingleStepMoveStrategy;
        private readonly IMoveStrategy _nonCaptureDoubleStepMoveStrategy;
        private readonly IMoveStrategy _captureStrategy;
        private bool _hasMoved = false;
        private IMoveStrategy _nonCaptureMoveStrategy;

        public PawnMove(bool isPlayer, IBoard boardUtility)
        {
            _nonCaptureDoubleStepMoveStrategy = isPlayer
                ? new DoubleStepMove(boardUtility, Directions.Up)
                : new DoubleStepMove(boardUtility, Directions.Down);

            _nonCaptureSingleStepMoveStrategy = isPlayer
                ? new SingleStepMove(boardUtility, Directions.Up)
                : new SingleStepMove(boardUtility, Directions.Down);

            _nonCaptureMoveStrategy = _nonCaptureDoubleStepMoveStrategy;

            _captureStrategy = isPlayer
                ? new DiagonalCaptureMove(boardUtility, new[] { Directions.UpLeft, Directions.UpRight })
                : new DiagonalCaptureMove(boardUtility, new[] { Directions.DownLeft, Directions.DownRight });
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            _nonCaptureMoveStrategy.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
            _captureStrategy.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
        }

        public void SwitchStrategy()
        {
            if (!_hasMoved)
            {
                _hasMoved = true;
                _nonCaptureMoveStrategy = _nonCaptureSingleStepMoveStrategy;
            }
        }
    }

    public class QueenMove : IMoveStrategy
    {
        private readonly IMoveStrategy _eightDirectionalMultiStepMovement;

        public QueenMove(IBoard boardUtility)
        {
            _eightDirectionalMultiStepMovement = new MultiStepMove(boardUtility, Directions.EightDirections);
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction) =>
            _eightDirectionalMultiStepMovement.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
    }

    public class KnightMove : IMoveStrategy
    {
        private readonly IBoard _boardUtility;

        public KnightMove(IBoard boardUtility)
        {
            _boardUtility = boardUtility;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            foreach (Vector2Int jump in Directions.KnightMoves)
            {
                Vector2Int to = currentTile + jump;

                if (BoardUtilities.IsWithinBoard(to) && !_boardUtility.ContainsAllyPieceAt(to, isPlayerPieceSelected))
                    onGetLegalMoveAction?.Invoke(to);
            }
        }
    }

    public class KingMove : IMoveStrategy
    {
        private readonly IBoard _boardUtility;

        public KingMove(IBoard boardUtility)
        {
            _boardUtility = boardUtility;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            foreach (Vector2Int dir in Directions.KingMoves)
            {
                Vector2Int to = currentTile + dir;

                if (BoardUtilities.IsWithinBoard(to) && !_boardUtility.ContainsAllyPieceAt(to, isPlayerPieceSelected))
                    onGetLegalMoveAction?.Invoke(to);
            }
        }
    }

    public class RookMove : IMoveStrategy
    {
        private readonly IMoveStrategy _orthogonalMultiStepMovement;

        public RookMove(IBoard boardUtility)
        {
            _orthogonalMultiStepMovement = new MultiStepMove(boardUtility, Directions.Orthogonals);
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction) =>
            _orthogonalMultiStepMovement.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
    }

    public class BishopMove : IMoveStrategy
    {
        private readonly IMoveStrategy _diagonalMultiStepMovement;

        public BishopMove(IBoard boardUtility)
        {
            _diagonalMultiStepMovement = new MultiStepMove(boardUtility, Directions.Diagonals);
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction) =>
            _diagonalMultiStepMovement.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
    }

    public class MultiStepMove : IMoveStrategy
    {
        private readonly IBoard _boardUtility;
        private readonly Vector2Int[] _directions;

        public MultiStepMove(IBoard boardUtility, Vector2Int[] directions)
        {
            _boardUtility = boardUtility;
            _directions = directions;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            foreach (Vector2Int dir in _directions)
            {
                Vector2Int to = currentTile + dir;

                while (BoardUtilities.IsWithinBoard(to))
                {
                    if (_boardUtility.IsTileEmptyAt(to))
                    {
                        onGetLegalMoveAction?.Invoke(to);
                        to += dir;
                    }
                    else if (_boardUtility.ContainsOpponentPieceAt(to, isPlayerPieceSelected))
                    {
                        onGetLegalMoveAction?.Invoke(to);
                        break;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }
    }

    public class SingleStepMove : IMoveStrategy
    {
        private readonly IBoard _boardUtility;
        private readonly Vector2Int _direction;

        public SingleStepMove(IBoard boardUtility, Vector2Int direction)
        {
            _boardUtility = boardUtility;
            _direction = direction;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            Vector2Int to = currentTile + _direction;

            if (BoardUtilities.IsWithinBoard(to) && _boardUtility.IsTileEmptyAt(to))
                onGetLegalMoveAction?.Invoke(to);
        }
    }

    public class DoubleStepMove : IMoveStrategy
    {
        private readonly IBoard _boardUtility;
        private readonly Vector2Int _direction;

        public DoubleStepMove(IBoard boardUtility, Vector2Int direction)
        {
            _boardUtility = boardUtility;
            _direction = direction;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            Vector2Int oneStep = currentTile + _direction;
            Vector2Int twoStep = currentTile + _direction * 2;

            if (BoardUtilities.IsWithinBoard(oneStep) && _boardUtility.IsTileEmptyAt(oneStep))
            {
                onGetLegalMoveAction?.Invoke(oneStep);

                if (BoardUtilities.IsWithinBoard(twoStep) && _boardUtility.IsTileEmptyAt(twoStep))
                    onGetLegalMoveAction?.Invoke(twoStep);
            }
        }
    }

    public class DiagonalCaptureMove : IMoveStrategy
    {
        private readonly IBoard _boardUtility;
        private readonly Vector2Int[] _captureDirections;

        public DiagonalCaptureMove(IBoard boardUtility, Vector2Int[] captureDirections)
        {
            _boardUtility = boardUtility;
            _captureDirections = captureDirections;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            foreach (var dir in _captureDirections)
            {
                Vector2Int to = currentTile + dir;
                if (BoardUtilities.IsWithinBoard(to) &&
                    !_boardUtility.IsTileEmptyAt(to) &&
                    _boardUtility.ContainsOpponentPieceAt(to, isPlayerPieceSelected))
                {
                    onGetLegalMoveAction?.Invoke(to);
                }
            }
        }
    }
}

// ----------------------------------------

// FILE: MoveStrategyFactory.cs
// PATH: Assets/Scripts/ChessPieces/MoveStrategyFactory.cs
// ----------------------------------------

namespace Chess2D.Piece
{
    public class MoveStrategyFactory
    {
        private Board.IBoard _boardUtility;

        public MoveStrategyFactory(Board.IBoard boardUtility)
        {
            _boardUtility = boardUtility;
        }

        public IMoveStrategy GetPieceMoveStrategy(PieceData data)
        {
            IMoveStrategy moveStrategy = null;

            switch (data.Type)
            {
                case PieceType.Pawn:
                    moveStrategy = new PawnMove(data.IsPlayer, _boardUtility);
                    break;
                case PieceType.Rook:
                    moveStrategy = new RookMove(_boardUtility);
                    break;
                case PieceType.Knight:
                    moveStrategy = new KnightMove(_boardUtility);
                    break;
                case PieceType.Bishop:
                    moveStrategy = new BishopMove(_boardUtility);
                    break;
                case PieceType.Queen:
                    moveStrategy = new QueenMove(_boardUtility);
                    break;
                case PieceType.King:
                    moveStrategy = new KingMove(_boardUtility);
                    break;
            }

            return moveStrategy;
        }

        public IMoveStrategy GetPawnSingleStepMoveStrategy(bool isPlayer) => isPlayer
                            ? new SingleStepMove(_boardUtility, Directions.Up)
                            : new SingleStepMove(_boardUtility, Directions.Down);
    }
}

// ----------------------------------------

// FILE: PieceData.cs
// PATH: Assets/Scripts/ChessPieces/PieceData.cs
// ----------------------------------------

namespace Chess2D.Piece
{
    public class PieceData
    {
        public PieceType Type { get; }
        public bool IsPlayer { get; }

        public PieceData(PieceType type, bool isPlayer)
        {
            Type = type;
            IsPlayer = isPlayer;
        }
    }
}

// ----------------------------------------

// FILE: PieceFactory.cs
// PATH: Assets/Scripts/ChessPieces/PieceFactory.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Piece
{
    public class PieceFactory<T> where T : Object
    {
        private readonly PieceSet<T> _pieceSet;

        public PieceFactory(PieceSet<T> pieceSet)
        {
            _pieceSet = pieceSet;
        }

        public T GetPiece(PieceType type)
        {
            T piece = null;

            switch (type)
            {
                case PieceType.Pawn: piece = _pieceSet.Pawn; break;
                case PieceType.Rook: piece = _pieceSet.Rook; break;
                case PieceType.Knight: piece = _pieceSet.Knight; break;
                case PieceType.Bishop: piece = _pieceSet.Bishop; break;
                case PieceType.Queen: piece = _pieceSet.Queen; break;
                case PieceType.King: piece = _pieceSet.King; break;
            }

            return Object.Instantiate(piece);
        }
    }
}

// ----------------------------------------

// FILE: PieceRenderer.cs
// PATH: Assets/Scripts/ChessPieces/PieceRenderer.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Piece
{
    public class PieceRenderer : MonoBehaviour
    {
        public void SetWorldPosition(Vector3Int position) => transform.position = position;
        public void SetInActive() => gameObject.SetActive(false);
        internal void SetActive() => gameObject.SetActive(true);
    }
}

// ----------------------------------------

// FILE: PieceSet.cs
// PATH: Assets/Scripts/ChessPieces/PieceSet.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Piece
{
    [System.Serializable]
    public class PieceSet<T> where T : Object
    {
        public T Pawn;
        public T Rook;
        public T Knight;
        public T Bishop;
        public T Queen;
        public T King;
    }
}

// ----------------------------------------

// FILE: PieceType.cs
// PATH: Assets/Scripts/ChessPieces/PieceType.cs
// ----------------------------------------

namespace Chess2D.Piece
{
    public enum PieceType
    {
        Pawn,
        Rook,
        Knight,
        Bishop,
        Queen,
        King
    }
}

// ----------------------------------------

// FILE: Highlighter.cs
// PATH: Assets/Scripts/Highlighter/Highlighter.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Highlight
{
    /// <summary>
    /// Controls tile highlighting using a finite state machine (FSM)
    /// </summary>
    public class Highlighter : MonoBehaviour
    {
        [SerializeField] private HighlightSpritesDatabase _colorThemeSO;
        private SpriteRenderer _renderer;

        private void Awake() => _renderer = GetComponentInChildren<SpriteRenderer>();

        public void Highlight(HighlightType type)
        {
            switch (type)
            {
                case HighlightType.Select:
                    ApplyHighlight(_colorThemeSO.SelectionHighlightSprite);
                    break;

                case HighlightType.EmptyTile:
                    ApplyHighlight(_colorThemeSO.EmptyTileHighlightSprite);
                    break;

                // case HighlightType.Special:
                //     ApplyHighlight(_colorThemeSO.SpecialHighlightSprite);
                //     break;

                case HighlightType.Capture:
                    ApplyHighlight(_colorThemeSO.CaptureHighlightSprite);
                    break;
            }
        }

        private void ApplyHighlight(Sprite sprite) => _renderer.sprite = sprite;
    }
}

// ----------------------------------------

// FILE: HighlighterManager.cs
// PATH: Assets/Scripts/Highlighter/HighlighterManager.cs
// ----------------------------------------

using Chess2D.Events;
using UnityEngine;

namespace Chess2D.Highlight
{
    public class HighlighterManager : MonoBehaviour
    {
        [SerializeField] private Highlighter _highlighterPrefab;
        [SerializeField] private GameEvents _gameEvents;

        private readonly Highlighter[,] _highlighters = new Highlighter[8, 8];

        private void Awake() => InitHighlighters();

        private void OnEnable()
        {
            _gameEvents.HighlightEvent.OnEventRaised += Highlight;
            _gameEvents.UnHighlightEvent.OnEventRaised += UnHighlight;
        }

        private void OnDisable()
        {
            _gameEvents.HighlightEvent.OnEventRaised -= Highlight;
            _gameEvents.UnHighlightEvent.OnEventRaised -= UnHighlight;
        }

        public void InitHighlighters()
        {
            for (int row = 0; row < 8; row++)
            {
                for (int col = 0; col < 8; col++)
                {
                    Highlighter highlighter = Instantiate(_highlighterPrefab, new Vector3(col, row), Quaternion.identity, transform);

                    highlighter.transform.name = $"Highlighter_C{col}_R{row}";

                    highlighter.gameObject.SetActive(false);

                    _highlighters[row, col] = highlighter;
                }
            }
        }

        public void Highlight((Vector2Int worldPosition, HighlightType type) highlightData)
        {
            Vector2Int pos = highlightData.worldPosition;
            HighlightType type = highlightData.type;

            Highlighter highlighter = _highlighters[pos.y, pos.x];
            highlighter.gameObject.SetActive(true);
            highlighter.Highlight(type);
        }

        public void UnHighlight(Vector2Int worldPosition)
        {
            Highlighter highlighter = _highlighters[worldPosition.y, worldPosition.x];

            highlighter.gameObject.SetActive(false);
        }
    }
}

// ----------------------------------------

// FILE: HighlightType.cs
// PATH: Assets/Scripts/Highlighter/HighlightType.cs
// ----------------------------------------

namespace Chess2D.Highlight
{
    public enum HighlightType
    {
        Select,
        EmptyTile,
        Special,
        Capture
    }
}

// ----------------------------------------

// FILE: PlayerController.cs
// PATH: Assets/Scripts/Player/PlayerController.cs
// ----------------------------------------

using System.Collections.Generic;
using Chess2D.Board.Utilities;
using Chess2D.Events;
using Chess2D.Highlight;
using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.Player
{
    public class PlayerController : MonoBehaviour
    {
        [SerializeField] private GameEvents _gameEvents;
        private Camera _mainCamera;
        private ChessPiece _selectedPiece;
        private readonly List<Vector2Int> _selectedPieceLegalMoves = new();
        private Board.IBoard _board;
        private bool _isPlayerTurn = true;

        private void Awake()
        {
            _mainCamera = Camera.main;
        }

        private void Start()
        {
            _board = GameManager.Instance.Board;
        }

        private void OnEnable()
        {
            _gameEvents.SwitchTurnToPlayerEvent.OnEventRaised += EnablePlayerTurn;
            _gameEvents.SwitchTurnToAIEvent.OnEventRaised += DisablePlayerTurn;
        }

        private void OnDisable()
        {
            _gameEvents.SwitchTurnToPlayerEvent.OnEventRaised -= EnablePlayerTurn;
            _gameEvents.SwitchTurnToAIEvent.OnEventRaised -= DisablePlayerTurn;
        }

        private void Update()
        {
            if (!_isPlayerTurn)
                return;

            HandleMouseInput();
        }

        private void HandleMouseInput()
        {
            Vector3 inputPos = Vector3.zero;
            bool inputDown = false;

#if UNITY_EDITOR || UNITY_STANDALONE || UNITY_WEBGL
            inputDown = Input.GetMouseButtonDown(0);
            inputPos = Input.mousePosition;
#else
            if (Input.touchCount > 0)
            {
                Touch touch = Input.GetTouch(0);
                inputPos = touch.position;
                inputDown = touch.phase == TouchPhase.Began;
            }
#endif
            if (inputDown)
            {
                Vector2 mouseWorldPos = _mainCamera.ScreenToWorldPoint(inputPos);
                Vector2Int input = Vector2Int.FloorToInt(mouseWorldPos);

                if (!BoardUtilities.IsWithinBoard(input)) return;

                if (_board.TryGetPlayerPieceAt(input, out ChessPiece piece))
                {
                    // If new piece selected, unhighlight previous
                    if (_selectedPiece != null && _selectedPiece != piece)
                    {
                        _gameEvents.UnHighlightEvent.RaiseEvent(_selectedPiece.BoardPosition);
                        ClearValidMoves();
                    }

                    _selectedPiece = piece;
                    _gameEvents.HighlightEvent.RaiseEvent((input, HighlightType.Select));
                    _selectedPiece.MoveStrategy.CalculateLegalMoves(true, input, OnGetLegalMove);
                }
                else
                {
                    if (_selectedPiece != null && _selectedPieceLegalMoves.Contains(input))
                    {
                        ClearValidMoves();

                        Vector2Int previousPosition = _selectedPiece.BoardPosition;
                        _selectedPiece.SetPiecePosition(input);

                        if (_board.TryCapturePieceAt(input, true, out ChessPiece capturedPiece))
                        {
                            if (capturedPiece != null)
                                _gameEvents.PieceCaptureEvent.RaiseEvent(capturedPiece);

                            if (capturedPiece.PieceType == PieceType.King)
                                _gameEvents.WinEvent.RaiseEvent(null);
                        }

                        _board.SetOccupiedPieceAt(null, previousPosition);
                        _board.SetOccupiedPieceAt(_selectedPiece, input);

                        if (_selectedPiece.MoveStrategy is IMoveStrategySwitch postMoveAware)
                            postMoveAware.SwitchStrategy();

                        _gameEvents.PlayerMadeMoveEvent.RaiseEvent(input);

                        DisablePlayerTurn(null); // Lock input after move
                    }
                }
            }
        }

        private void EnablePlayerTurn(Empty e)
        {
            _isPlayerTurn = true;
        }

        private void DisablePlayerTurn(Empty e)
        {
            _isPlayerTurn = false;
            ClearValidMoves(); // Clear highlights first
            _selectedPiece = null; // Then clear selection
        }

        private void ClearValidMoves()
        {
            foreach (Vector2Int position in _selectedPieceLegalMoves)
            {
                _gameEvents.UnHighlightEvent.RaiseEvent(position);
            }

            if (_selectedPiece != null)
                _gameEvents.UnHighlightEvent.RaiseEvent(_selectedPiece.BoardPosition);

            _selectedPieceLegalMoves.Clear();
        }

        private void OnGetLegalMove(Vector2Int position)
        {
            _gameEvents.HighlightEvent.RaiseEvent((
                new Vector2Int(position.x, position.y),
                _board.ContainsOpponentPieceAt(position, true)
                    ? HighlightType.Capture
                    : HighlightType.EmptyTile));

            _selectedPieceLegalMoves.Add(position);
        }
    }
}

// ----------------------------------------

// FILE: InertialScrollRect.cs
// PATH: Assets/Scripts/UI/InertialScrollRect.cs
// ----------------------------------------

using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Chess2D.UI
{
    public class InertialScrollRect : ScrollRect
    {
        private bool _draggingByTouch;
        private bool _isDragging;
        private Vector2 _prevPosition = Vector2.zero;

        protected override void OnDestroy()
        {
            base.OnDestroy();

            StopAllCoroutines();
        }

        public override void OnBeginDrag(PointerEventData eventData)
        {
            base.OnBeginDrag(eventData);

            _draggingByTouch = eventData.pointerId != -1;
            _isDragging = true;
        }

        public override void OnEndDrag(PointerEventData eventData)
        {
            base.OnEndDrag(eventData);

            _isDragging = false;
        }

        protected override void OnDisable()
        {
            base.OnDisable();

            _isDragging = false;
        }

        public override void Rebuild(CanvasUpdate executing)
        {
            base.Rebuild(executing);

            if (executing == CanvasUpdate.PostLayout)
            {
                _prevPosition = content.anchoredPosition;
            }
        }

        protected override void LateUpdate()
        {
            base.LateUpdate();

            float deltaTime = Time.unscaledDeltaTime;
            if (deltaTime > 0.0f && _isDragging && inertia)
            {
                Vector3 newVelocity = (content.anchoredPosition - _prevPosition) / deltaTime;
                velocity = _draggingByTouch ? newVelocity : Vector3.Lerp(velocity, newVelocity, deltaTime * 10f);
            }

            _prevPosition = content.anchoredPosition;
        }
    }
}

// ----------------------------------------

// FILE: SpriteToggle.cs
// PATH: Assets/Scripts/UI/SpriteToggle.cs
// ----------------------------------------

using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
public class SpriteToggle : MonoBehaviour
{
    [SerializeField] private Image _iconImage;
    [SerializeField] private Sprite _onSprite;
    [SerializeField] private Sprite _offSprite;

    private Toggle _toggle;

    private void Awake()
    {
        _toggle = GetComponent<Toggle>();
        
        UpdateIcon(_toggle.isOn);

        _toggle.onValueChanged.AddListener(UpdateIcon);
    }

    private void UpdateIcon(bool isOn) => _iconImage.sprite = isOn ? _onSprite : _offSprite;
}

// ----------------------------------------

// FILE: TutorialManager.cs
// PATH: Assets/Scripts/UI/TutorialManager.cs
// ----------------------------------------

using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Chess2D.UI
{
    public class TutorialManager : MonoBehaviour
    {
        [SerializeField] private GameObject tutorialPanel;
        [SerializeField] private TextMeshProUGUI tutorialText;
        [SerializeField] private Button nextButton;

        [TextArea(2, 5)]
        [SerializeField] private string[] tutorialSteps;

        private int currentStep = 0;

        void Start()
        {
            tutorialPanel.SetActive(true);
            ShowStep(0);
            nextButton.onClick.AddListener(NextStep);
        }

        private void ShowStep(int stepIndex)
        {
            if (stepIndex < tutorialSteps.Length)
            {
                tutorialText.text = tutorialSteps[stepIndex];
            }
        }

        private void NextStep()
        {
            currentStep++;

            if (currentStep >= tutorialSteps.Length)
            {
                tutorialPanel.SetActive(false); // Hide when done
            }
            else
            {
                ShowStep(currentStep);
            }
        }
    }
}

// ----------------------------------------

// FILE: UICapturedPieces.cs
// PATH: Assets/Scripts/UI/UICapturedPieces.cs
// ----------------------------------------

using Chess2D.Events;
using Chess2D.Piece;
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

namespace Chess2D.UI
{
    public class UICapturedPieces : MonoBehaviour
    {
        [SerializeField] private GameEvents _gameEvents;

        private readonly Dictionary<ChessPiece, Image> _capturedPieceMap = new();
        private PieceFactory<Image> _playerPieceFactory;
        private PieceFactory<Image> _aiPieceFactory;
        [SerializeField] private Transform _aiPieceTransform;
        [SerializeField] private Transform _playerPieceTransform;

        private void OnEnable()
        {
            _gameEvents.PieceCaptureEvent.OnEventRaised += OnPieceCaptured;
            _gameEvents.InitializePieceEvent.OnEventRaised += AddPieceUI;
        }

        private void OnDisable()
        {
            _gameEvents.PieceCaptureEvent.OnEventRaised -= OnPieceCaptured;
            _gameEvents.InitializePieceEvent.OnEventRaised -= AddPieceUI;
        }

        public void Initialize(PieceFactory<Image> playerPieceFactory, PieceFactory<Image> aiPieceFactory)
        {
            _playerPieceFactory = playerPieceFactory;
            _aiPieceFactory = aiPieceFactory;
        }

        private void AddPieceUI(ChessPiece piece)
        {
            Image pieceImage = piece.IsPlayer ? _playerPieceFactory.GetPiece(piece.PieceType) : _aiPieceFactory.GetPiece(piece.PieceType);

            pieceImage.transform.SetParent(piece.IsPlayer ? _playerPieceTransform : _aiPieceTransform);

            pieceImage.gameObject.SetActive(false);

            _capturedPieceMap.Add(piece, pieceImage);
        }

        private void OnPieceCaptured(ChessPiece piece)
        {
            if (_capturedPieceMap.TryGetValue(piece, out var pieceImage))
            {
                pieceImage.gameObject.SetActive(true);
            }
        }
    }
}

// ----------------------------------------

// FILE: UIManager.cs
// PATH: Assets/Scripts/UI/UIManager.cs
// ----------------------------------------

using Chess2D.Piece;
using Chess2D.ScriptableObjects;
using UnityEngine;
using UnityEngine.UI;

namespace Chess2D.UI
{
    public class UIManager : MonoBehaviour
    {
        [SerializeField] private GameObject _winStats;
        [SerializeField] private UIMoveHistory _uiMoveHistory;
        [SerializeField] private UIChessPieceDatabase _uiPieceDatabase;
        [SerializeField] private UICapturedPieces _capturedPiecesUI;

        public void InitUI(bool isPlayerDark)
        {
            PieceFactory<Image> playerPieceFactory;
            PieceFactory<Image> aiPieceFactory;

            if (isPlayerDark)
            {
                playerPieceFactory = new PieceFactory<Image>(_uiPieceDatabase.BlackPieceSet);
                aiPieceFactory = new PieceFactory<Image>(_uiPieceDatabase.WhitePieceSet);
            }
            else
            {
                playerPieceFactory = new PieceFactory<Image>(_uiPieceDatabase.WhitePieceSet);
                aiPieceFactory = new PieceFactory<Image>(_uiPieceDatabase.BlackPieceSet);
            }

            _capturedPiecesUI.Initialize(playerPieceFactory, aiPieceFactory);
        }

        public void ShowWinStats()
        {
            _winStats.SetActive(true);
        }
    }
}

// ----------------------------------------

// FILE: UIMoveHistory.cs
// PATH: Assets/Scripts/UI/UIMoveHistory.cs
// ----------------------------------------

using TMPro;
using UnityEngine;
using System.Collections.Generic;
using Chess2D.Events;

namespace Chess2D.UI
{
    public class UIMoveHistory : MonoBehaviour
    {
        [SerializeField] private TMP_Text _moveTextPrefab;
        [SerializeField] private RectTransform _scrollCeontent;
        [SerializeField] private GameEvents _gameEvents;

        private readonly List<TMP_Text> _moveLines = new();
        private string _playerMove = "";
        private string _aiMove = "";
        private int _currentMoveCount;

        private void OnEnable()
        {
            _gameEvents.AIMadeMoveEvent.OnEventRaised += HandleAIMove;
            _gameEvents.PlayerMadeMoveEvent.OnEventRaised += HandlePlayerMove;
        }

        private void OnDisable()
        {
            _gameEvents.AIMadeMoveEvent.OnEventRaised -= HandleAIMove;
            _gameEvents.PlayerMadeMoveEvent.OnEventRaised -= HandlePlayerMove;
        }

        private void HandlePlayerMove(Vector2Int move)
        {
            // Player moves always start a new turn
            _currentMoveCount++;
            AddMove(_currentMoveCount, move, true);
        }

        private void HandleAIMove(Vector2Int move)
        {
            // AI moves update the current turn's entry
            AddMove(_currentMoveCount, move, false);
        }

        private void AddMove(int moveCount, Vector2Int position, bool isPlayer)
        {
            // If this is the same turn as before, update the last entry
            if (_moveLines.Count > 0 && _currentMoveCount == moveCount && !isPlayer)
            {
                SetMove(moveCount, position, isPlayer);
                return;
            }

            // New turn, create a new entry
            gameObject.SetActive(true);

            TMP_Text newLine = Instantiate(_moveTextPrefab, _scrollCeontent);
            _moveLines.Add(newLine);

            // Reset moves for new turn
            _playerMove = "";
            _aiMove = "";

            SetMove(moveCount, position, isPlayer);
        }

        private void SetMove(int moveCount, Vector2Int position, bool isPlayer)
        {
            // Convert board coordinates to chess notation
            // Assuming 0 = A, 0 = 1
            string square = ((char)(position.x + 65)).ToString() + (position.y + 1);

            if (isPlayer)
                _playerMove = square;
            else
                _aiMove = square;

            // Always update the last line in the list
            TMP_Text lastLine = _moveLines[_moveLines.Count - 1];
            lastLine.text = $"{moveCount}. {_playerMove} {_aiMove}";
        }
    }
}

// ----------------------------------------

// FILE: UITimer.cs
// PATH: Assets/Scripts/UI/UITimer.cs
// ----------------------------------------

using TMPro;
using UnityEngine;

namespace Chess2D.UI
{
    public class UITimer : MonoBehaviour
    {
        [SerializeField] private TMP_Text _timerText;

        public void UpdateTimer(int min, int sec)
        {
            _timerText.text = $"{min:00}:{sec:00}";
        }
    }
}

// ----------------------------------------

// FILE: ChessPieceRendererDatabase.cs
// PATH: Assets/Scripts/ChessPieceRendererDatabase.cs
// ----------------------------------------

using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.ScriptableObjects
{
    [CreateAssetMenu(fileName = "ChessPieceDatabase", menuName = "Custom/ChessPiece Database")]
    public class ChessPieceRendererDatabase : ChessPieceDatabase<PieceRenderer> { }
}

// ----------------------------------------

// FILE: GameEvents.cs
// PATH: Assets/Scripts/GameEvents.cs
// ----------------------------------------

using Chess2D.Piece;
using UnityEngine;
using UnityEngine.Events;

namespace Chess2D.Events
{
    [CreateAssetMenu(menuName = "Custom/GameEvents")]
    public class GameEvents : ScriptableObject
    {
        public EventChannel<ChessPiece> PieceCaptureEvent = new();
        public EventChannel<Vector2Int> PlayerMadeMoveEvent = new();
        public EventChannel<Vector2Int> AIMadeMoveEvent = new();
        public EventChannel<Empty> TimeEndEvent = new();
        public EventChannel<Vector2Int> UnHighlightEvent = new();
        public EventChannel<(Vector2Int, Highlight.HighlightType)> HighlightEvent = new();
        public EventChannel<Empty> WinEvent = new();
        public EventChannel<bool> SwitchTurnEvent = new();
        public EventChannel<Empty> SwitchTurnToPlayerEvent = new();
        public EventChannel<Empty> SwitchTurnToAIEvent = new();
        public EventChannel<ChessPiece> InitializePieceEvent = new();
        public EventChannel<AudioClip> PlayOneShotAudio = new();
    }

    public class Empty { }

    public class EventChannel<T>
    {
        public event UnityAction<T> OnEventRaised;
        public void RaiseEvent(T value) => OnEventRaised?.Invoke(value);
    }
}

// ----------------------------------------

// FILE: GameManager.cs
// PATH: Assets/Scripts/GameManager.cs
// ----------------------------------------

using Chess2D.Events;
using Chess2D.Piece;
using Chess2D.ScriptableObjects;
using Chess2D.UI;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Chess2D
{
    public class GameManager : MonoBehaviour
    {
        public static GameManager Instance { get; private set; }
        [SerializeField] private UIManager _uiManager;
        [SerializeField] private HighlightSpritesDatabase _spritesDatabase;
        [SerializeField] private ChessPieceRendererDatabase _pieceDatabase;
        [SerializeField] private GameEvents _gameEvents;
        [SerializeField] private Transform _playerPieceContainer;
        [SerializeField] private Transform _aiPieceContainer;

        private bool _isPlayerDark = false;

        public Board.ChessBoard Board { get; private set; }

        private void Awake()
        {
            Instance = this;
        }

        private void OnEnable()
        {
            _gameEvents.WinEvent.OnEventRaised += WinGame;
        }

        private void OnDisable()
        {
            _gameEvents.WinEvent.OnEventRaised -= WinGame;
        }

        private void Start()
        {
            _isPlayerDark = PlayerPrefs.GetInt("PlayerColor", 0) == 0;

            _uiManager.InitUI(_isPlayerDark);

            Board = new Board.ChessBoard(_gameEvents.InitializePieceEvent);

            MoveStrategyFactory moveStrategyFactory = new(Board);

            if (_isPlayerDark)
            {
                Board.InitializeBoard(
                    moveStrategyFactory,
                    new PieceFactory<PieceRenderer>(_pieceDatabase.BlackPieceSet),
                    new PieceFactory<PieceRenderer>(_pieceDatabase.WhitePieceSet),
                    _playerPieceContainer,
                    _aiPieceContainer
                );
            }
            else
            {
                Board.InitializeBoard(
                    moveStrategyFactory,
                    new PieceFactory<PieceRenderer>(_pieceDatabase.WhitePieceSet),
                    new PieceFactory<PieceRenderer>(_pieceDatabase.BlackPieceSet),
                    _playerPieceContainer,
                    _aiPieceContainer
                );
            }
        }

        private void WinGame(Empty empty = null)
        {
            _uiManager.ShowWinStats();
        }

        public void RestartGame() => SceneManager.LoadSceneAsync(SceneManager.GetActiveScene().name);
    }
}

// ----------------------------------------

// FILE: HighlightSpritesDatabase.cs
// PATH: Assets/Scripts/HighlightSpritesDatabase.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D
{
    [CreateAssetMenu(fileName = "SpritesDatabase", menuName = "Custom/Sprites Database")]
    public class HighlightSpritesDatabase : ScriptableObject
    {
        [Header("Highlighters Sprite")]
        [field: SerializeField] public Sprite SelectionHighlightSprite { get; private set; }
        [field: SerializeField] public Sprite CaptureHighlightSprite { get; private set; }
        [field: SerializeField] public Sprite EmptyTileHighlightSprite { get; private set; }
        //[field: SerializeField] public Sprite SpecialHighlightSprite { get; private set; }
    }
}

// ----------------------------------------

// FILE: Timer.cs
// PATH: Assets/Scripts/Timer.cs
// ----------------------------------------

using Chess2D.Events;
using Chess2D.UI;
using UnityEngine;

namespace Chess2D
{
    public class Timer : MonoBehaviour
    {
        [SerializeField] private float _totalTime = 60f;
        [SerializeField] private UITimer _uiTimer;
        [SerializeField] private GameEvents _gameEvents;

        private bool _isPaused = true;
        private float _remainingTime;

        private void OnEnable()
        {
            _gameEvents.AIMadeMoveEvent.OnEventRaised += ResetTimer;
            _gameEvents.PlayerMadeMoveEvent.OnEventRaised += ResetTimer;
            _gameEvents.SwitchTurnToAIEvent.OnEventRaised += ResetTimer;
            _gameEvents.SwitchTurnToPlayerEvent.OnEventRaised += ResetTimer;
        }

        private void OnDisable()
        {
            _gameEvents.AIMadeMoveEvent.OnEventRaised -= ResetTimer;
            _gameEvents.PlayerMadeMoveEvent.OnEventRaised -= ResetTimer;
            _gameEvents.SwitchTurnToAIEvent.OnEventRaised -= ResetTimer;
            _gameEvents.SwitchTurnToPlayerEvent.OnEventRaised -= ResetTimer;
        }

        private void Start()
        {
            RestartCountdown();
        }

        private void Update()
        {
            if (_isPaused) return;

            _remainingTime -= Time.deltaTime;
            if (_remainingTime <= 0f)
            {
                _remainingTime = 0f;
                _isPaused = true;
                _gameEvents.TimeEndEvent.RaiseEvent(null);
            }

            UpdateUITimer();
        }

        private void ResetTimer(Empty empty) => RestartCountdown();
        private void ResetTimer(Vector2Int empty) => RestartCountdown();

        public void RestartCountdown(float? newTime = null)
        {
            _remainingTime = newTime ?? _totalTime;
            _isPaused = false;
            UpdateUITimer();
        }

        public void PauseCountdown() => _isPaused = true;
        public void ResumeCountdown() => _isPaused = false;

        private void UpdateUITimer()
        {
            int min = Mathf.FloorToInt(_remainingTime / 60);
            int sec = Mathf.FloorToInt(_remainingTime % 60);
            _uiTimer.UpdateTimer(min, sec);
        }
    }
}

// ----------------------------------------

// FILE: TimerData.cs
// PATH: Assets/Scripts/TimerData.cs
// ----------------------------------------

namespace Chess2D
{
    [System.Serializable]
    public class TimerData
    {
        public float totalTime;
    }
}

// ----------------------------------------

// FILE: TurnManager.cs
// PATH: Assets/Scripts/TurnManager.cs
// ----------------------------------------

using Chess2D.Events;
using TMPro;
using UnityEngine;

namespace Chess2D
{
    public class TurnManager : MonoBehaviour
    {
        [SerializeField] private TMP_Text _turnText;
        [SerializeField] private GameEvents _gameEvents;
        private bool _isPlayerTurn = true;

        private void OnEnable()
        {
            _gameEvents.AIMadeMoveEvent.OnEventRaised += SetToPlayerTurn;
            _gameEvents.PlayerMadeMoveEvent.OnEventRaised += SetToAITurn;
            _gameEvents.TimeEndEvent.OnEventRaised += SwitchTurn;
        }

        private void OnDisable()
        {
            _gameEvents.AIMadeMoveEvent.OnEventRaised -= SetToPlayerTurn;
            _gameEvents.PlayerMadeMoveEvent.OnEventRaised -= SetToAITurn;
            _gameEvents.TimeEndEvent.OnEventRaised -= SwitchTurn;
        }

        /// <summary>
        /// Called by timer timeout to swap turns.
        /// </summary>
        private void SwitchTurn(Empty e)
        {
            if (_isPlayerTurn)
                SetToAITurn();
            else
                SetToPlayerTurn();
        }

        private void SetToPlayerTurn(Vector2Int e) => SetToPlayerTurn();
        private void SetToAITurn(Vector2Int e) => SetToAITurn();
        
        private void SetToPlayerTurn()
        {
            _isPlayerTurn = true;
            _gameEvents.SwitchTurnToPlayerEvent.RaiseEvent(null);
            _gameEvents.SwitchTurnEvent.RaiseEvent(true); // true = player's turn
            UpdateTurnUI();
        }

        private void SetToAITurn()
        {
            _isPlayerTurn = false;
            _gameEvents.SwitchTurnToAIEvent.RaiseEvent(null);
            _gameEvents.SwitchTurnEvent.RaiseEvent(false); // false = AI's turn
            UpdateTurnUI();
        }

        private void UpdateTurnUI()
        {
            if (_turnText != null)
                _turnText.text = _isPlayerTurn ? "Player Turn" : "AI Turn";
        }
    }
}

// ----------------------------------------

// FILE: UIChessPieceDatabase.cs
// PATH: Assets/Scripts/UIChessPieceDatabase.cs
// ----------------------------------------

using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.ScriptableObjects
{
    [CreateAssetMenu(fileName = "UIChessPieceDatabase", menuName = "Custom/UI Chess Piece Database")]
    public class UIChessPieceDatabase : ChessPieceDatabase<UnityEngine.UI.Image> { }
}

// ----------------------------------------

