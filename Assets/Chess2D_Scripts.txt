// Combined Script Export
// Generated on: 2025-08-11 14:56:32
// Total files: 33
// ============================================================

// FILE: AIController.cs
// PATH: Assets/Scripts/AI/AIController.cs
// ----------------------------------------

using System.Collections.Generic;
using System.Threading.Tasks;
using Chess2D.Events;
using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.AI
{
    public class AIController : MonoBehaviour
    {
        [SerializeField] private GameEvents _gameEvents;
        [Range(1, 5)][SerializeField] private int _depth = 2;
        private Board.ChessBoard _board;

        private void Start() => _board = GameManager.Instance.Board;

        public async void MakeAIMove()
        {
            // Run the minimax search in a background thread
            Move bestMove = await Task.Run(() =>
                GetBestMove(_depth, float.NegativeInfinity, float.PositiveInfinity, true)
            );

            if (bestMove != null)
                ExecuteMove(bestMove);
        }

        private Move GetBestMove(int depth, float alpha, float beta, bool maximizingPlayer)
        {
            List<Move> allMoves = GetAllPossibleMoves(false);

            Move bestMove = null;
            float bestEval = maximizingPlayer ? float.NegativeInfinity : float.PositiveInfinity;

            foreach (var move in allMoves)
            {
                var captured = SimulateMove(move);

                float eval = Minimax(depth - 1, alpha, beta, !maximizingPlayer);

                UndoMove(move, captured);

                if (maximizingPlayer)
                {
                    if (eval > bestEval)
                    {
                        bestEval = eval;
                        bestMove = move;
                    }
                    alpha = Mathf.Max(alpha, eval);
                }
                else
                {
                    if (eval < bestEval)
                    {
                        bestEval = eval;
                        bestMove = move;
                    }
                    beta = Mathf.Min(beta, eval);
                }

                if (beta <= alpha)
                    break;
            }

            return bestMove;
        }

        private float Minimax(int depth, float alpha, float beta, bool maximizingPlayer)
        {
            if (depth == 0)
                return EvaluateBoard();

            List<Move> moves = GetAllPossibleMoves(!maximizingPlayer);

            float bestEval = maximizingPlayer ? float.NegativeInfinity : float.PositiveInfinity;

            foreach (var move in moves)
            {
                var captured = SimulateMove(move);

                float eval = Minimax(depth - 1, alpha, beta, !maximizingPlayer);

                UndoMove(move, captured);

                if (maximizingPlayer)
                {
                    bestEval = Mathf.Max(bestEval, eval);
                    alpha = Mathf.Max(alpha, eval);
                }
                else
                {
                    bestEval = Mathf.Min(bestEval, eval);
                    beta = Mathf.Min(beta, eval);
                }

                if (beta <= alpha)
                    break;
            }

            return bestEval;
        }

        private float EvaluateBoard()
        {
            float eval = 0f;

            for (int row = 0; row < 8; row++)
            {
                for (int col = 0; col < 8; col++)
                {
                    if (!_board.TryGetOccupiedPieceAt(new Vector2Int(col, row), out var piece)) continue;

                    float value = GetPieceValue(piece.PieceData.Type);
                    eval += piece.PieceData.IsPlayer ? -value : value;
                }
            }

            return eval;
        }

        private float GetPieceValue(PieceType type) => type switch
        {
            PieceType.Pawn => 1f,
            PieceType.Knight => 4f,
            PieceType.Bishop => 3f,
            PieceType.Rook => 5f,
            PieceType.Queen => 9f,
            PieceType.King => 100f,
            _ => 0f
        };

        private List<Move> GetAllPossibleMoves(bool isPlayer)
        {
            List<Move> moves = new();

            for (int row = 0; row < 8; row++)
            {
                for (int col = 0; col < 8; col++)
                {
                    if (!_board.TryGetOccupiedPieceAt(new Vector2Int(col, row), out var piece)) continue;

                    if (piece.PieceData.IsPlayer == isPlayer)
                    {
                        Vector2Int current = new(col, row);

                        piece.MoveStrategy.CalculateLegalMoves(isPlayer, current, to =>
                        {
                            moves.Add(new Move
                            {
                                from = current,
                                to = to,
                                movedPiece = piece,
                                ContainsCapturablePiece = _board.ContainsOpponentPieceAt(to, isPlayer)
                            });
                        });
                    }
                }
            }

            return moves;
        }

        private ChessPiece SimulateMove(Move move)
        {
            ChessPiece captured = _board.GetOccupiedPieceAt(move.to);

            _board.SetOccupiedPieceAt(null, move.from);
            _board.SetOccupiedPieceAt(move.movedPiece, move.to);

            return captured;
        }

        private void UndoMove(Move move, ChessPiece captured)
        {
            _board.SetOccupiedPieceAt(null, move.to);
            _board.SetOccupiedPieceAt(move.movedPiece, move.from);

            if (captured != null)
                _board.SetOccupiedPieceAt(captured, move.to);
        }

        private void ExecuteMove(Move move)
        {
            move.movedPiece.SetPiecePosition(move.to);

            if (move.ContainsCapturablePiece && _board.TryCapturePieceAt(move.to, false, out var capturedPiece))
            {
                if (capturedPiece.PieceType == PieceType.King)
                    _gameEvents.WinEvent.RaiseEvent(null);
            }

            _board.SetOccupiedPieceAt(null, move.from);
            _board.SetOccupiedPieceAt(move.movedPiece, move.to);
        }
    }
}

// ----------------------------------------

// FILE: Move.cs
// PATH: Assets/Scripts/AI/Move.cs
// ----------------------------------------

using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.AI
{
    public class Move
    {
        public Vector2Int from;
        public Vector2Int to;
        public ChessPiece movedPiece;
        public bool ContainsCapturablePiece;
    }
}

// ----------------------------------------

// FILE: BoardUtilities.cs
// PATH: Assets/Scripts/Board/Utilities/BoardUtilities.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Board.Utilities
{
    public static class BoardUtilities
    {
        public static bool IsWithinBoard(Vector2Int tile) => tile.x < 8 && tile.x >= 0 && tile.y < 8 && tile.y >= 0;
    }
}

// ----------------------------------------

// FILE: BoardData.cs
// PATH: Assets/Scripts/Board/BoardData.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Board
{
    public class BoardData
    {
        private readonly TileData[,] _tileDatas;

        public BoardData(int size)
        {
            _tileDatas = new TileData[size, size];

            for (int row = 0; row < size; row++)
            {
                for (int col = 0; col < size; col++)
                {
                    _tileDatas[row, col] = new TileData();
                }
            }
        }

        public bool IsMoveValidAt(Vector2Int boardPosition) => _tileDatas[boardPosition.y, boardPosition.x].IsValidForMove;
        public void UnMarkMoveValidAt(Vector2Int boardPosition) => _tileDatas[boardPosition.y, boardPosition.x].UnMarkValidForMove();
        public void MarkMoveValidAt(Vector2Int boardPosition) => _tileDatas[boardPosition.y, boardPosition.x].MarkValidForMove();
    }
}

// ----------------------------------------

// FILE: BoardRenderer.cs
// PATH: Assets/Scripts/Board/BoardRenderer.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Board
{
    public class BoardRenderer
    {
        private readonly SpriteRenderer[,] _tileRenderers;

        public BoardRenderer(int size, Color darkTileColor, Color lightTileColor, GameObject tilePrefab, Transform parentTransform)
        {
            Transform rowTransform = null;

            _tileRenderers = new SpriteRenderer[size, size];

            for (int row = 0; row < size; row++)
            {
                for (int col = 0; col < size; col++)
                {
                    if (col == 0)
                    {
                        rowTransform = new GameObject($"Row_{row}").transform;
                        rowTransform.SetParent(parentTransform);
                    }

                    bool isDark = (row + col) % 2 == 0;

                    GameObject tileObj = Object.Instantiate(
                        tilePrefab,
                        new Vector3(col, row),
                        Quaternion.identity,
                        rowTransform);

                    tileObj.name = isDark ? $"DarkTile(C{col}_R{row})" : $"LightTile(C{col}_R{row})";

                    SpriteRenderer tileRenderer = tileObj.GetComponentInChildren<SpriteRenderer>();

                    tileRenderer.color = isDark ? darkTileColor : lightTileColor;

                    _tileRenderers[row, col] = tileRenderer;
                }
            }
        }

        public void SetBoardTheme(Color darkTileColor, Color lightTileColor)
        {
            for (int row = 0; row < _tileRenderers.GetLength(0); row++)
            {
                for (int col = 0; col < _tileRenderers.GetLength(1); col++)
                {
                    _tileRenderers[row, col].color = (row + col) % 2 == 0 ? darkTileColor : lightTileColor;
                }
            }
        }
    }
}

// ----------------------------------------

// FILE: ChessBoard.cs
// PATH: Assets/Scripts/Board/ChessBoard.cs
// ----------------------------------------

using System;
using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.Board
{
    public class ChessBoard : IBoardUtility
    {
        private const int BOARD_SIZE = 8;
        private readonly BoardData _boardData;
        private readonly BoardRenderer _boardRenderer;
        private readonly ChessPiece[,] _pieceGrid = new ChessPiece[BOARD_SIZE, BOARD_SIZE];

        public ChessBoard(GameObject tilePrefab, Color darkTileColor, Color lightTileColor, Transform boardTransform)
        {
            _boardData = new BoardData(BOARD_SIZE);

            _boardRenderer = new BoardRenderer(
                BOARD_SIZE,
                darkTileColor,
                lightTileColor,
                tilePrefab,
                boardTransform);
        }

        public void InitializePieces(bool isPlayerDarkColored, PieceFactory pieceFactory, Transform playerPieceTransform, Transform aiPieceTransform)
        {
            Color playerColor = isPlayerDarkColored ? Color.blue : Color.white;
            Color aiColor = isPlayerDarkColored ? Color.white : Color.blue;

            int playerBackRow = 0;
            int playerFrontRow = 1;
            int aiBackRow = 7;
            int aiFrontRow = 6;

            PieceType[] backRowSetup =
            {
                PieceType.Rook, PieceType.Knight, PieceType.Bishop,
                PieceType.Queen, PieceType.King, PieceType.Bishop,
                PieceType.Knight, PieceType.Rook
            };

            for (int col = 0; col < BOARD_SIZE; col++)
            {
                // Pawns
                CreateAndPlacePiece(pieceFactory, new PieceData(PieceType.Pawn, true), new Vector2Int(col, playerFrontRow), playerPieceTransform, playerColor);
                CreateAndPlacePiece(pieceFactory, new PieceData(PieceType.Pawn, false), new Vector2Int(col, aiFrontRow), aiPieceTransform, aiColor);

                // Back row pieces
                CreateAndPlacePiece(pieceFactory, new PieceData(backRowSetup[col], true), new Vector2Int(col, playerBackRow), playerPieceTransform, playerColor);
                CreateAndPlacePiece(pieceFactory, new PieceData(backRowSetup[col], false), new Vector2Int(col, aiBackRow), aiPieceTransform, aiColor);
            }
        }

        private void CreateAndPlacePiece(PieceFactory pieceFactory, PieceData pieceData, Vector2Int gridIndex, Transform container, Color color)
        {
            ChessPiece piece = pieceFactory.CreatePiece(pieceData);
            piece.SetPiecePosition(gridIndex);
            piece.Transform.SetParent(container);
            piece.SetPieceColor(color);
            _pieceGrid[gridIndex.y, gridIndex.x] = piece;
        }

        public bool TryGetPlayerPieceAt(Vector2Int boardPosition, out ChessPiece playerPiece)
        {
            playerPiece = _pieceGrid[boardPosition.y, boardPosition.x];

            return playerPiece != null && playerPiece.IsPlayer == true;
        }

        #region IBoardUtility Methods
        public bool IsTileEmptyAt(Vector2Int boardPosition) => _pieceGrid[boardPosition.y, boardPosition.x] == null;
        public bool ContainsOpponentPieceAt(Vector2Int boardPosition, bool isPlayerPieceSelected) => !IsTileEmptyAt(boardPosition) && _pieceGrid[boardPosition.y, boardPosition.x].IsPlayer ^ isPlayerPieceSelected;

        public bool ContainsAllyPieceAt(Vector2Int boardPosition, bool isPlayerPieceSelected) => !IsTileEmptyAt(boardPosition) && _pieceGrid[boardPosition.y, boardPosition.x].IsPlayer == isPlayerPieceSelected;
        #endregion

        public void SetBoardTheme(Color darkTileColor, Color lightTileColor) => _boardRenderer.SetBoardTheme(darkTileColor, lightTileColor);

        public void SetOccupiedPieceAt(ChessPiece occupiedPiece, Vector2Int boardPosition) => _pieceGrid[boardPosition.y, boardPosition.x] = occupiedPiece;

        public bool IsMoveValidAt(Vector2Int boardPosition) => _boardData.IsMoveValidAt(boardPosition);
        public void MarkMoveValidAt(Vector2Int boardPosition) => _boardData.MarkMoveValidAt(boardPosition);
        public void UnMarkMoveValidAt(Vector2Int boardPosition) => _boardData.UnMarkMoveValidAt(boardPosition);

        public bool TryCapturePieceAt(Vector2Int boardPosition, bool isPlayerPieceSelected, out ChessPiece capturedPiece)
        {
            if (ContainsOpponentPieceAt(boardPosition, isPlayerPieceSelected))
            {
                capturedPiece = _pieceGrid[boardPosition.y, boardPosition.x];

                if (capturedPiece != null)
                {
                    capturedPiece.SetInActive();
                    SetOccupiedPieceAt(null, boardPosition);
                }

                return true;
            }

            capturedPiece = null;

            return false;
        }

        public bool TryGetOccupiedPieceAt(Vector2Int boardPosition, out ChessPiece occupiedPiece)
        {
            occupiedPiece = _pieceGrid[boardPosition.y, boardPosition.x];

            return occupiedPiece != null;
        }

        public ChessPiece GetOccupiedPieceAt(Vector2Int boardPosition) => _pieceGrid[boardPosition.y, boardPosition.x];
    }
}

// ----------------------------------------

// FILE: IBoardUtility.cs
// PATH: Assets/Scripts/Board/IBoardUtility.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Board
{
    public interface IBoardUtility
    {
        bool IsTileEmptyAt(Vector2Int boardPosition);
        bool ContainsOpponentPieceAt(Vector2Int boardPosition, bool isPlayer);
        bool ContainsAllyPieceAt(Vector2Int boardPosition, bool isPlayer);
    }
}

// ----------------------------------------

// FILE: TileData.cs
// PATH: Assets/Scripts/Board/TileData.cs
// ----------------------------------------

namespace Chess2D.Board
{
    /// <summary>
    /// Represents the state of a single tile on the chessboard.
    /// Stores information about whether it is occupied and if it is currently a valid move target.
    /// </summary>
    public class TileData
    {
        /// <summary>
        /// Indicates whether this tile is currently marked as valid for a move.
        /// Typically set during legal move calculation and cleared after a move is made or cancelled.
        /// </summary>
        public bool IsValidForMove { get; private set; }

        /// <summary>
        /// Marks this tile as a valid move destination for the currently selected piece.
        /// </summary>
        public void MarkValidForMove() => IsValidForMove = true;

        /// <summary>
        /// Removes the "valid move" mark from this tile, making it a normal tile again.
        /// </summary>
        public void UnMarkValidForMove() => IsValidForMove = false;
    }
}

// ----------------------------------------

// FILE: ChessPiece.cs
// PATH: Assets/Scripts/ChessPieces/ChessPiece.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Piece
{
    public class ChessPiece
    {
        private readonly PieceRenderer _pieceRenderer;
        public IMoveStrategy MoveStrategy { get; private set; }
        public PieceData PieceData { get; }
        public bool IsPlayer => PieceData.IsPlayer;
        public PieceType PieceType => PieceData.Type;
        public Transform Transform => _pieceRenderer.transform;
        public Vector2Int BoardPosition => new(
            (int)_pieceRenderer.transform.position.x,
            (int)_pieceRenderer.transform.position.y);

        public ChessPiece(
            IMoveStrategy moveStrategy,
            PieceData pieceData,
            PieceRenderer pieceRenderer)
        {
            PieceData = pieceData;
            _pieceRenderer = Object.Instantiate(pieceRenderer);

            MoveStrategy = moveStrategy;
        }

        public void SetMoveStrategy(IMoveStrategy moveStrategy) => MoveStrategy = moveStrategy;
        public void SetPieceColor(Color color) => _pieceRenderer.SetColor(color);
        public void SetPiecePosition(Vector2Int position) => _pieceRenderer.SetWorldPosition(new Vector3Int(position.x, position.y));
        public void SetInActive() => _pieceRenderer.SetInActive();
        public void SetActive() => _pieceRenderer.SetActive();
    }
}

// ----------------------------------------

// FILE: Directions.cs
// PATH: Assets/Scripts/ChessPieces/Directions.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Piece
{
    public static class Directions
    {
        public static readonly Vector2Int Up = Vector2Int.up;
        public static readonly Vector2Int Down = Vector2Int.down;
        public static readonly Vector2Int Left = Vector2Int.left;
        public static readonly Vector2Int Right = Vector2Int.right;

        public static readonly Vector2Int UpLeft = Vector2Int.up + Vector2Int.left;
        public static readonly Vector2Int UpRight = Vector2Int.up + Vector2Int.right;
        public static readonly Vector2Int DownLeft = Vector2Int.down + Vector2Int.left;
        public static readonly Vector2Int DownRight = Vector2Int.down + Vector2Int.right;

        public static readonly Vector2Int[] Diagonals =
        {
            UpLeft, UpRight, DownLeft, DownRight
        };

        public static readonly Vector2Int[] Orthogonals =
        {
            Up, Down, Left, Right
        };

        public static readonly Vector2Int[] EightDirections =
        {
            UpLeft, UpRight, DownLeft, DownRight,
            Up, Down, Left, Right
        };

        public static readonly Vector2Int[] KnightMoves =
        {
            new(1, 2), new(2, 1),
            new(2, -1), new(1, -2),
            new(-1, -2), new(-2, -1),
            new(-2, 1), new(-1, 2)
        };

        public static readonly Vector2Int[] KingMoves = EightDirections;
    }
}

// ----------------------------------------

// FILE: IMoveStrategy.cs
// PATH: Assets/Scripts/ChessPieces/IMoveStrategy.cs
// ----------------------------------------

using System;
using Chess2D.Board;
using Chess2D.Board.Utilities;
using UnityEngine;

namespace Chess2D.Piece
{
    public interface IMoveStrategy
    {
        void CalculateLegalMoves(
            bool isPlayerPieceSelected,
            Vector2Int currentTile,
            Action<Vector2Int> onGetLegalMoveAction);
    }

    public interface IMoveStrategySwitch
    {
        void SwitchStrategy();
    }

    public class PawnMove : IMoveStrategy, IMoveStrategySwitch
    {
        private readonly IMoveStrategy _nonCaptureSingleStepMoveStrategy;
        private readonly IMoveStrategy _nonCaptureDoubleStepMoveStrategy;
        private readonly IMoveStrategy _captureStrategy;
        private bool _hasMoved = false;
        private IMoveStrategy _nonCaptureMoveStrategy;

        public PawnMove(bool isPlayer, IBoardUtility boardUtility)
        {
            _nonCaptureDoubleStepMoveStrategy = isPlayer
                ? new DoubleStepMove(boardUtility, Directions.Up)
                : new DoubleStepMove(boardUtility, Directions.Down);

            _nonCaptureSingleStepMoveStrategy = isPlayer
                ? new SingleStepMove(boardUtility, Directions.Up)
                : new SingleStepMove(boardUtility, Directions.Down);

            _nonCaptureMoveStrategy = _nonCaptureDoubleStepMoveStrategy;

            _captureStrategy = isPlayer
                ? new DiagonalCaptureMove(boardUtility, new[] { Directions.UpLeft, Directions.UpRight })
                : new DiagonalCaptureMove(boardUtility, new[] { Directions.DownLeft, Directions.DownRight });
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            _nonCaptureMoveStrategy.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
            _captureStrategy.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
        }

        public void SwitchStrategy()
        {
            if (!_hasMoved)
            {
                _hasMoved = true;
                _nonCaptureMoveStrategy = _nonCaptureSingleStepMoveStrategy;
            }
        }
    }

    public class QueenMove : IMoveStrategy
    {
        private readonly IMoveStrategy _eightDirectionalMultiStepMovement;

        public QueenMove(IBoardUtility boardUtility)
        {
            _eightDirectionalMultiStepMovement = new MultiStepMove(boardUtility, Directions.EightDirections);
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction) =>
            _eightDirectionalMultiStepMovement.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
    }

    public class KnightMove : IMoveStrategy
    {
        private readonly IBoardUtility _boardUtility;

        public KnightMove(IBoardUtility boardUtility)
        {
            _boardUtility = boardUtility;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            foreach (Vector2Int jump in Directions.KnightMoves)
            {
                Vector2Int to = currentTile + jump;

                if (BoardUtilities.IsWithinBoard(to) && !_boardUtility.ContainsAllyPieceAt(to, isPlayerPieceSelected))
                    onGetLegalMoveAction?.Invoke(to);
            }
        }
    }

    public class KingMove : IMoveStrategy
    {
        private readonly IBoardUtility _boardUtility;

        public KingMove(IBoardUtility boardUtility)
        {
            _boardUtility = boardUtility;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            foreach (Vector2Int dir in Directions.KingMoves)
            {
                Vector2Int to = currentTile + dir;

                if (BoardUtilities.IsWithinBoard(to) && !_boardUtility.ContainsAllyPieceAt(to, isPlayerPieceSelected))
                    onGetLegalMoveAction?.Invoke(to);
            }
        }
    }

    public class RookMove : IMoveStrategy
    {
        private readonly IMoveStrategy _orthogonalMultiStepMovement;

        public RookMove(IBoardUtility boardUtility)
        {
            _orthogonalMultiStepMovement = new MultiStepMove(boardUtility, Directions.Orthogonals);
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction) =>
            _orthogonalMultiStepMovement.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
    }

    public class BishopMove : IMoveStrategy
    {
        private readonly IMoveStrategy _diagonalMultiStepMovement;

        public BishopMove(IBoardUtility boardUtility)
        {
            _diagonalMultiStepMovement = new MultiStepMove(boardUtility, Directions.Diagonals);
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction) =>
            _diagonalMultiStepMovement.CalculateLegalMoves(isPlayerPieceSelected, currentTile, onGetLegalMoveAction);
    }

    public class MultiStepMove : IMoveStrategy
    {
        private readonly IBoardUtility _boardUtility;
        private readonly Vector2Int[] _directions;

        public MultiStepMove(IBoardUtility boardUtility, Vector2Int[] directions)
        {
            _boardUtility = boardUtility;
            _directions = directions;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            foreach (Vector2Int dir in _directions)
            {
                Vector2Int to = currentTile + dir;

                while (BoardUtilities.IsWithinBoard(to))
                {
                    if (_boardUtility.IsTileEmptyAt(to))
                    {
                        onGetLegalMoveAction?.Invoke(to);
                        to += dir;
                    }
                    else if (_boardUtility.ContainsOpponentPieceAt(to, isPlayerPieceSelected))
                    {
                        onGetLegalMoveAction?.Invoke(to);
                        break;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }
    }

    public class SingleStepMove : IMoveStrategy
    {
        private readonly IBoardUtility _boardUtility;
        private readonly Vector2Int _direction;

        public SingleStepMove(IBoardUtility boardUtility, Vector2Int direction)
        {
            _boardUtility = boardUtility;
            _direction = direction;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            Vector2Int to = currentTile + _direction;

            if (BoardUtilities.IsWithinBoard(to) && _boardUtility.IsTileEmptyAt(to))
                onGetLegalMoveAction?.Invoke(to);
        }
    }

    public class DoubleStepMove : IMoveStrategy
    {
        private readonly IBoardUtility _boardUtility;
        private readonly Vector2Int _direction;

        public DoubleStepMove(IBoardUtility boardUtility, Vector2Int direction)
        {
            _boardUtility = boardUtility;
            _direction = direction;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            Vector2Int oneStep = currentTile + _direction;
            Vector2Int twoStep = currentTile + _direction * 2;

            if (BoardUtilities.IsWithinBoard(oneStep) && _boardUtility.IsTileEmptyAt(oneStep))
            {
                onGetLegalMoveAction?.Invoke(oneStep);

                if (BoardUtilities.IsWithinBoard(twoStep) && _boardUtility.IsTileEmptyAt(twoStep))
                    onGetLegalMoveAction?.Invoke(twoStep);
            }
        }
    }

    public class DiagonalCaptureMove : IMoveStrategy
    {
        private readonly IBoardUtility _boardUtility;
        private readonly Vector2Int[] _captureDirections;

        public DiagonalCaptureMove(IBoardUtility boardUtility, Vector2Int[] captureDirections)
        {
            _boardUtility = boardUtility;
            _captureDirections = captureDirections;
        }

        public void CalculateLegalMoves(bool isPlayerPieceSelected, Vector2Int currentTile, Action<Vector2Int> onGetLegalMoveAction)
        {
            foreach (var dir in _captureDirections)
            {
                Vector2Int to = currentTile + dir;
                if (BoardUtilities.IsWithinBoard(to) &&
                    !_boardUtility.IsTileEmptyAt(to) &&
                    _boardUtility.ContainsOpponentPieceAt(to, isPlayerPieceSelected))
                {
                    onGetLegalMoveAction?.Invoke(to);
                }
            }
        }
    }
}

// ----------------------------------------

// FILE: MoveStrategyFactory.cs
// PATH: Assets/Scripts/ChessPieces/MoveStrategyFactory.cs
// ----------------------------------------

namespace Chess2D.Piece
{
    public class MoveStrategyFactory
    {
        private Board.IBoardUtility _boardUtility;

        public MoveStrategyFactory(Board.IBoardUtility boardUtility)
        {
            _boardUtility = boardUtility;
        }

        public IMoveStrategy GetPieceMoveStrategy(PieceData data)
        {
            IMoveStrategy moveStrategy = null;

            switch (data.Type)
            {
                case PieceType.Pawn:
                    moveStrategy = new PawnMove(data.IsPlayer, _boardUtility);
                    break;
                case PieceType.Rook:
                    moveStrategy = new RookMove(_boardUtility);
                    break;
                case PieceType.Knight:
                    moveStrategy = new KnightMove(_boardUtility);
                    break;
                case PieceType.Bishop:
                    moveStrategy = new BishopMove(_boardUtility);
                    break;
                case PieceType.Queen:
                    moveStrategy = new QueenMove(_boardUtility);
                    break;
                case PieceType.King:
                    moveStrategy = new KingMove(_boardUtility);
                    break;
            }

            return moveStrategy;
        }

        public IMoveStrategy GetPawnSingleStepMoveStrategy(bool isPlayer) => isPlayer
                            ? new SingleStepMove(_boardUtility, Directions.Up)
                            : new SingleStepMove(_boardUtility, Directions.Down);
    }
}

// ----------------------------------------

// FILE: PieceData.cs
// PATH: Assets/Scripts/ChessPieces/PieceData.cs
// ----------------------------------------

namespace Chess2D.Piece
{
    public class PieceData
    {
        public PieceType Type { get; }
        public bool IsPlayer { get; }

        public PieceData(PieceType type, bool isPlayer)
        {
            Type = type;
            IsPlayer = isPlayer;
        }
    }
}

// ----------------------------------------

// FILE: PieceFactory.cs
// PATH: Assets/Scripts/ChessPieces/PieceFactory.cs
// ----------------------------------------

using Chess2D.ScriptableObjects;

namespace Chess2D.Piece
{
    public class PieceFactory
    {
        private readonly PieceRendererDatabase _pieceDatabase;
        private readonly MoveStrategyFactory _moveStrategyFactory;

        public PieceFactory(PieceRendererDatabase pieceDatabase, MoveStrategyFactory moveStrategyFactory)
        {
            _pieceDatabase = pieceDatabase;
            _moveStrategyFactory = moveStrategyFactory;
        }

        public ChessPiece CreatePiece(PieceData data)
        {
            ChessPiece piece = data.Type switch
            {
                PieceType.Pawn => GetPiece(_moveStrategyFactory.GetPieceMoveStrategy(data), data, _pieceDatabase.Pawn),
                PieceType.Rook => GetPiece(_moveStrategyFactory.GetPieceMoveStrategy(data), data, _pieceDatabase.Rook),
                PieceType.Knight => GetPiece(_moveStrategyFactory.GetPieceMoveStrategy(data), data, _pieceDatabase.Knight),
                PieceType.Bishop => GetPiece(_moveStrategyFactory.GetPieceMoveStrategy(data), data, _pieceDatabase.Bishop),
                PieceType.Queen => GetPiece(_moveStrategyFactory.GetPieceMoveStrategy(data), data, _pieceDatabase.Queen),
                PieceType.King => GetPiece(_moveStrategyFactory.GetPieceMoveStrategy(data), data, _pieceDatabase.King),
                _ => throw new System.ArgumentOutOfRangeException(nameof(data), $"Unknown piece type: {data}")
            };

            return piece;
        }

        private ChessPiece GetPiece(
            IMoveStrategy moveStrategy,
            PieceData pieceData,
            PieceRenderer pieceRenderer) => new(moveStrategy, pieceData, pieceRenderer);
    }
}

// ----------------------------------------

// FILE: PieceRenderer.cs
// PATH: Assets/Scripts/ChessPieces/PieceRenderer.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Piece
{
    public class PieceRenderer : MonoBehaviour
    {
        [SerializeField] private SpriteRenderer _fillRenderer;

        private void Awake()
        {
            if (_fillRenderer == null)
                Debug.LogError("Forgot to assign sprite renderer component for the chess piece prefab");
        }

        public void SetColor(Color color) => _fillRenderer.color = color;
        public void SetWorldPosition(Vector3Int position) => transform.position = position;
        public void SetInActive() => gameObject.SetActive(false);
        internal void SetActive() => gameObject.SetActive(true);
    }
}

// ----------------------------------------

// FILE: PieceType.cs
// PATH: Assets/Scripts/ChessPieces/PieceType.cs
// ----------------------------------------

namespace Chess2D.Piece
{
    public enum PieceType
    {
        Pawn,
        Rook,
        Knight,
        Bishop,
        Queen,
        King
    }
}

// ----------------------------------------

// FILE: Highlighter.cs
// PATH: Assets/Scripts/Highlighter/Highlighter.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.Highlight
{
    /// <summary>
    /// Controls tile highlighting using a finite state machine (FSM)
    /// </summary>
    public class Highlighter : MonoBehaviour
    {
        [SerializeField] private HighlightSpritesDatabase _colorThemeSO;
        private SpriteRenderer _renderer;

        private void Awake() => _renderer = GetComponentInChildren<SpriteRenderer>();

        public void Highlight(HighlightType type)
        {
            switch (type)
            {
                case HighlightType.Select:
                    ApplyHighlight(_colorThemeSO.SelectionHighlightSprite);
                    break;

                case HighlightType.EmptyTile:
                    ApplyHighlight(_colorThemeSO.EmptyTileHighlightSprite);
                    break;

                // case HighlightType.Special:
                //     ApplyHighlight(_colorThemeSO.SpecialHighlightSprite);
                //     break;

                case HighlightType.Capture:
                    ApplyHighlight(_colorThemeSO.CaptureHighlightSprite);
                    break;
            }
        }

        private void ApplyHighlight(Sprite sprite) => _renderer.sprite = sprite;
    }
}

// ----------------------------------------

// FILE: HighlighterManager.cs
// PATH: Assets/Scripts/Highlighter/HighlighterManager.cs
// ----------------------------------------

using Chess2D.Events;
using UnityEngine;

namespace Chess2D.Highlight
{
    public class HighlighterManager : MonoBehaviour
    {
        [SerializeField] private Highlighter _highlighterPrefab;
        [SerializeField] private GameEvents _gameEvents;

        private readonly Highlighter[,] _highlighters = new Highlighter[8, 8];

        private void Awake() => InitHighlighters();

        private void OnEnable()
        {
            _gameEvents.HighlightEvent.OnEventRaised += Highlight;
            _gameEvents.UnHighlightEvent.OnEventRaised += UnHighlight;
        }

        private void OnDisable()
        {
            _gameEvents.HighlightEvent.OnEventRaised -= Highlight;
            _gameEvents.UnHighlightEvent.OnEventRaised -= UnHighlight;
        }

        public void InitHighlighters()
        {
            for (int row = 0; row < 8; row++)
            {
                for (int col = 0; col < 8; col++)
                {
                    Highlighter highlighter = Instantiate(_highlighterPrefab, new Vector3(col, row), Quaternion.identity, transform);

                    highlighter.transform.name = $"Highlighter_C{col}_R{row}";

                    highlighter.gameObject.SetActive(false);

                    _highlighters[row, col] = highlighter;
                }
            }
        }

        public void Highlight((Vector2Int worldPosition, HighlightType type) highlightData)
        {
            Vector2Int pos = highlightData.worldPosition;
            HighlightType type = highlightData.type;

            Highlighter highlighter = _highlighters[pos.y, pos.x];
            highlighter.gameObject.SetActive(true);
            highlighter.Highlight(type);
        }

        public void UnHighlight(Vector2Int worldPosition)
        {
            Highlighter highlighter = _highlighters[worldPosition.y, worldPosition.x];

            highlighter.gameObject.SetActive(false);
        }
    }
}

// ----------------------------------------

// FILE: PlayerController.cs
// PATH: Assets/Scripts/Player/PlayerController.cs
// ----------------------------------------

using System.Collections.Generic;
using Chess2D.Board.Utilities;
using Chess2D.Events;
using Chess2D.Highlight;
using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.Player
{
    public class PlayerController : MonoBehaviour
    {
        [SerializeField] private GameEvents _gameEvents;
        private Camera _mainCamera;
        private ChessPiece _selectedPiece;
        private readonly List<Vector2Int> _selectedPieceValidMoves = new();
        private Board.ChessBoard _board;

        private void Awake()
        {
            _mainCamera = Camera.main;
        }

        private void Start()
        {
            _board = GameManager.Instance.Board;
        }

        private void Update()
        {
            Vector3 inputPos = Vector3.zero;

            bool inputDown = false;

#if UNITY_EDITOR || UNITY_STANDALONE || UNITY_WEBGL
            inputDown = Input.GetMouseButtonDown(0);
            inputPos = Input.mousePosition;
#else
        if (Input.touchCount > 0)
        {
            Touch touch = Input.GetTouch(0);
            inputPos = touch.position;
            inputDown = touch.phase == TouchPhase.Began;
        }
#endif
            if (inputDown)
            {
                Vector2 mouseWorldPos = _mainCamera.ScreenToWorldPoint(inputPos);

                Vector2Int input = new((int)mouseWorldPos.x, (int)mouseWorldPos.y);

                if (!BoardUtilities.IsWithinBoard(input)) return;

                if (_board.TryGetPlayerPieceAt(input, out ChessPiece piece))
                {
                    // if new piece selected unhighlight previous highlighters
                    if (_selectedPiece != null && _selectedPiece != piece)
                    {
                        _gameEvents.UnHighlightEvent.RaiseEvent(_selectedPiece.BoardPosition);

                        ClearValidMoves();
                    }

                    _selectedPiece = piece;
                    _gameEvents.HighlightEvent.RaiseEvent((input, HighlightType.Select));
                    _selectedPiece.MoveStrategy.CalculateLegalMoves(true, input, OnGetLegalMove);
                }
                else
                {
                    if (_board.IsMoveValidAt(input) && _selectedPiece != null)
                    {
                        ClearValidMoves();

                        _selectedPiece.SetPiecePosition(input);

                        if (_board.TryCapturePieceAt(input, true, out ChessPiece capturedPiece))
                        {
                            if (capturedPiece.PieceType == PieceType.King)
                                _gameEvents.WinEvent.RaiseEvent(null);
                        }

                        _board.SetOccupiedPieceAt(null, _selectedPiece.BoardPosition);

                        _board.SetOccupiedPieceAt(_selectedPiece, input);

                        if (_selectedPiece.MoveStrategy is IMoveStrategySwitch postMoveAware)
                            postMoveAware.SwitchStrategy();

                        _board.SetOccupiedPieceAt(null, _selectedPiece.BoardPosition);
                        _selectedPiece = null;
                    }
                }
            }
        }

        private void ClearValidMoves()
        {
            foreach (Vector2Int position in _selectedPieceValidMoves)
            {
                _gameEvents.UnHighlightEvent.RaiseEvent(position);

                _board.UnMarkMoveValidAt(position);
            }

            _gameEvents.UnHighlightEvent.RaiseEvent(_selectedPiece.BoardPosition);
            _selectedPieceValidMoves.Clear();
        }

        private void OnGetLegalMove(Vector2Int position)
        {
            _gameEvents.HighlightEvent.RaiseEvent((new Vector2Int(
                position.x,
                position.y), _board.ContainsOpponentPieceAt(
                    position,
                    true) ? HighlightType.Capture : HighlightType.EmptyTile));

            _board.MarkMoveValidAt(position);

            _selectedPieceValidMoves.Add(position);
        }
    }
}

// ----------------------------------------

// FILE: TutorialManager.cs
// PATH: Assets/Scripts/UI/TutorialManager.cs
// ----------------------------------------

using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Chess2D.UI
{
    public class TutorialManager : MonoBehaviour
    {
        [SerializeField] private GameObject tutorialPanel;
        [SerializeField] private TextMeshProUGUI tutorialText;
        [SerializeField] private Button nextButton;

        [TextArea(2, 5)]
        [SerializeField] private string[] tutorialSteps;

        private int currentStep = 0;

        void Start()
        {
            tutorialPanel.SetActive(true);
            ShowStep(0);
            nextButton.onClick.AddListener(NextStep);
        }

        private void ShowStep(int stepIndex)
        {
            if (stepIndex < tutorialSteps.Length)
            {
                tutorialText.text = tutorialSteps[stepIndex];
            }
        }

        private void NextStep()
        {
            currentStep++;

            if (currentStep >= tutorialSteps.Length)
            {
                tutorialPanel.SetActive(false); // Hide when done
            }
            else
            {
                ShowStep(currentStep);
            }
        }
    }
}

// ----------------------------------------

// FILE: UICapturedPieces.cs
// PATH: Assets/Scripts/UI/UICapturedPieces.cs
// ----------------------------------------

using System.Collections.Generic;
using Chess2D.Events;
using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.UI
{
    public class UICapturedPieces : MonoBehaviour
    {
        [SerializeField] private GameEvents _gameEvents;
        [SerializeField] private Transform _playerCapturedContainer;
        [SerializeField] private Transform _aiCapturedContainer;

        private List<PieceRenderer> _playerCaptured = new();
        private List<PieceRenderer> _aiCaptured = new();

        private void OnEnable()
        {
            _gameEvents.PieceCaptureEvent.OnEventRaised += OnPieceCaptured;
        }

        private void OnDisable()
        {
            _gameEvents.PieceCaptureEvent.OnEventRaised -= OnPieceCaptured;
        }

        private void OnPieceCaptured(PieceRenderer capturedRenderer)
        {
            // Make a small icon copy
            PieceRenderer icon = Instantiate(capturedRenderer, Vector3.zero, Quaternion.identity);
            icon.transform.localScale = Vector3.one * 0.5f; // smaller size
            icon.SetInActive(); // ensure original gameplay object is not active in the scene
            icon.gameObject.SetActive(true);

            // Decide where to show based on who owned the piece
            ChessPiece piece = capturedRenderer.GetComponent<ChessPiece>();
            bool wasPlayerPiece = piece != null && piece.IsPlayer;

            if (wasPlayerPiece)
            {
                icon.transform.SetParent(_aiCapturedContainer, false);
                _playerCaptured.Add(icon);
            }
            else
            {
                icon.transform.SetParent(_playerCapturedContainer, false);
                _aiCaptured.Add(icon);
            }
        }
    }
}

// ----------------------------------------

// FILE: UIEvaluationBar.cs
// PATH: Assets/Scripts/UI/UIEvaluationBar.cs
// ----------------------------------------

using UnityEngine;
using UnityEngine.UI;

namespace Chess2D.UI
{
    public class UIEvaluationBar : MonoBehaviour
    {
        [SerializeField] private Slider _slider;
        [SerializeField] private AI.AIController _aiController;
        [SerializeField] private float _maxEval = 50f;

        private void Update()
        {
            // Get board evaluation from AI
            float eval = 0;//_aiController.GetCurrentEvaluation();

            // Clamp so it fits the slider range
            eval = Mathf.Clamp(eval, -_maxEval, _maxEval);

            // Update slider value
            _slider.value = eval;
        }

        public void ShowWinner()
        {
            // if (eval > 0.5f)
            //     winnerText.text = "AI is Winning";
            // else if (eval < -0.5f)
            //     winnerText.text = "Player is Winning";
            // else
            //     winnerText.text = "Even";
        }
    }
}

// ----------------------------------------

// FILE: UIManager.cs
// PATH: Assets/Scripts/UI/UIManager.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D.UI
{
    public class UIManager : MonoBehaviour
    {
        [SerializeField] private GameObject _winStats;
        [SerializeField] private UIMoveHistory _uiMoveHistory;

        public void ShowWinStats()
        {
            _winStats.SetActive(true);
        }

        private void ChangeBoardColor()
        {
            //  Board.SetBoardTheme(Color.red, Color.yellow);
        }
    }
}

// ----------------------------------------

// FILE: UIMoveHistory.cs
// PATH: Assets/Scripts/UI/UIMoveHistory.cs
// ----------------------------------------

using System.Collections.Generic;
using UnityEngine;

namespace Chess2D.UI
{
    public class UIMoveHistory : MonoBehaviour
    {
        [SerializeField] private UIMoveItem _uiMoveItemPrefab;
        [SerializeField] private Transform _content;
        [SerializeField] private int _poolSize;
        private readonly List<UIMoveItem> _uiMoveItems = new();
        private int _currentMoveCount;

        private void Awake()
        {
            for (int i = 0; i < _poolSize; i++)
            {
                var moveItem = Instantiate(_uiMoveItemPrefab, _content);
                moveItem.gameObject.SetActive(false);
                _uiMoveItems.Add(moveItem);
            }
        }

        public void AddMove(int moveCount, int row, int col, bool isPlayer)
        {
            if (_currentMoveCount == moveCount)
            {
                _uiMoveItems[_currentMoveCount].SetMove(moveCount, row, col, isPlayer);
                return;
            }
            _currentMoveCount = moveCount;

            _uiMoveItems[_currentMoveCount].gameObject.SetActive(true);

            _uiMoveItems[_currentMoveCount].SetMove(moveCount, row, col, isPlayer);
        }
    }
}

// ----------------------------------------

// FILE: UIMoveItem.cs
// PATH: Assets/Scripts/UI/UIMoveItem.cs
// ----------------------------------------

using TMPro;
using UnityEngine;

namespace Chess2D.UI
{
    public class UIMoveItem : MonoBehaviour
    {
        [SerializeField] private TMP_Text _moveText;
        private string _playerMove = "";
        private string _aiMove = "";

        public void SetMove(int moveCount, int row, int col, bool isPlayer)
        {
            if (isPlayer)
            {
                _playerMove = ((char)(col + 64)).ToString() + row;
            }
            else
            {
                _aiMove = ((char)(col + 64)).ToString() + row;
            }

            _moveText.text = $"{moveCount}. {_playerMove} {_aiMove}";
        }
    }
}

// ----------------------------------------

// FILE: UITimer.cs
// PATH: Assets/Scripts/UI/UITimer.cs
// ----------------------------------------

using TMPro;
using UnityEngine;

namespace Chess2D.UI
{
    public class UITimer : MonoBehaviour
    {
        [SerializeField] private TMP_Text _timerText;

        public void UpdateTimer(int min, int sec)
        {
            _timerText.text = $"{min:00}:{sec:00}";
        }
    }
}

// ----------------------------------------

// FILE: CountdownTimer.cs
// PATH: Assets/Scripts/CountdownTimer.cs
// ----------------------------------------

using Chess2D.UI;
using UnityEngine;
using UnityEngine.Events;

namespace Chess2D
{
    public class CountdownTimer : MonoBehaviour
    {
        [SerializeField] private float _totalTime = 60f;
        [SerializeField] private UITimer _uiTimer;

        public UnityEvent OnTimerEnd; // Event triggered when timer hits zero

        private bool _isPaused = true;
        private float _remainingTime;

        private void Start()
        {
            _remainingTime = _totalTime;
            UpdateUITimer();
        }

        private void Update()
        {
            if (_isPaused) return;

            _remainingTime -= Time.deltaTime;
            if (_remainingTime <= 0f)
            {
                _remainingTime = 0f;
                _isPaused = true;
                OnTimerEnd?.Invoke();
            }

            UpdateUITimer();
        }

        public void RestartCountdown(float? newTime = null)
        {
            _remainingTime = newTime ?? _totalTime;
            _isPaused = false;
            UpdateUITimer();
        }

        public void PauseCountdown() => _isPaused = true;
        public void ResumeCountdown() => _isPaused = false;

        private void UpdateUITimer()
        {
            int min = Mathf.FloorToInt(_remainingTime / 60);
            int sec = Mathf.FloorToInt(_remainingTime % 60);
            _uiTimer.UpdateTimer(min, sec);
        }
    }
}

// ----------------------------------------

// FILE: GameEvents.cs
// PATH: Assets/Scripts/GameEvents.cs
// ----------------------------------------

using UnityEngine;
using UnityEngine.Events;

namespace Chess2D.Events
{
    [CreateAssetMenu(menuName = "Custom/GameEvents")]
    public class GameEvents : ScriptableObject
    {
        public EventChannel<Empty> LoseGameEvent = new();
        public EventChannel<Empty> GameCompleteEvent = new();
        public EventChannel<Empty> RestartGameEvent = new();
        public EventChannel<Empty> ExitGameEvent = new();
        public EventChannel<bool> GameActiveEvent = new();
        public EventChannel<Vector2Int> OngetLegalMoveEvent = new();
        public EventChannel<Piece.PieceRenderer> PieceCaptureEvent = new();
        public EventChannel<AudioClip> PlayOneShotAudioEvent = new();
        public EventChannel<Empty> MadeMove = new();
        public EventChannel<Vector2Int> UnHighlightEvent = new();
        public EventChannel<(Vector2Int, Highlight.HighlightType)> HighlightEvent = new();
        public EventChannel<Empty> KingCapturedEvent = new();
        public EventChannel<Empty> WinEvent = new();
    }

    public class Empty { }

    public class EventChannel<T>
    {
        public event UnityAction<T> OnEventRaised;
        public void RaiseEvent(T value) => OnEventRaised?.Invoke(value);
    }
}

// ----------------------------------------

// FILE: GameManager.cs
// PATH: Assets/Scripts/GameManager.cs
// ----------------------------------------

using Chess2D.Events;
using Chess2D.Piece;
using Chess2D.ScriptableObjects;
using Chess2D.UI;
using UnityEngine;

namespace Chess2D
{
    public class GameManager : MonoBehaviour
    {
        public static GameManager Instance { get; private set; }
        [SerializeField] private UIManager _uiManager;
        [SerializeField] private HighlightSpritesDatabase _spritesDatabase;
        [SerializeField] private PieceRendererDatabase _pieceDatabase;
        [SerializeField] private GameEvents _gameEvents;
        [SerializeField] private PieceRenderer _chessPiecePrefab;
        [SerializeField] private bool _isPlayerDark = false;
        [SerializeField] private Transform _playerPieceContainer;
        [SerializeField] private Transform _aiPieceContainer;
        [SerializeField] private GameObject _tilePrefab;
        [SerializeField] private Transform _boardTransform;
        [SerializeField] private UIMoveHistory _uiMoveHistory;
        private PieceFactory _pieceFactory;

        public Board.ChessBoard Board { get; private set; }

        public UIMoveHistory MoveHistory => _uiMoveHistory;
        private int _moveCount = 0;

        private void Awake()
        {
            Instance = this;

            Board = new Board.ChessBoard(
                _tilePrefab,
                Color.grey,
                Color.white,
                _boardTransform);

            MoveStrategyFactory moveStrategyFactory = new(Board);
            _pieceFactory = new PieceFactory(_pieceDatabase, moveStrategyFactory);

            Board.InitializePieces(_isPlayerDark, _pieceFactory, _playerPieceContainer, _aiPieceContainer);
        }

        private void OnEnable()
        {
            _gameEvents.WinEvent.OnEventRaised += WinGame;
        }

        private void OnDisable()
        {
            _gameEvents.WinEvent.OnEventRaised -= WinGame;
        }

        private void WinGame(Empty empty = null)
        {
            _uiManager.ShowWinStats();
        }

        public void RecordMove(Vector2Int position, bool isPlayer)
        {
            if (isPlayer)
                _moveCount++;

            _uiMoveHistory.AddMove(_moveCount, position.y + 1, position.x + 1, isPlayer);
        }
    }
}

// ----------------------------------------

// FILE: HighlightSpritesDatabase.cs
// PATH: Assets/Scripts/HighlightSpritesDatabase.cs
// ----------------------------------------

using UnityEngine;

namespace Chess2D
{
    [CreateAssetMenu(fileName = "SpritesDatabase", menuName = "Custom/Sprites Database")]
    public class HighlightSpritesDatabase : ScriptableObject
    {
        [Header("Highlighters Sprite")]
        [field: SerializeField] public Sprite SelectionHighlightSprite { get; private set; }
        [field: SerializeField] public Sprite CaptureHighlightSprite { get; private set; }
        [field: SerializeField] public Sprite EmptyTileHighlightSprite { get; private set; }
        //[field: SerializeField] public Sprite SpecialHighlightSprite { get; private set; }
    }
}

// ----------------------------------------

// FILE: PieceRendererDatabase.cs
// PATH: Assets/Scripts/PieceRendererDatabase.cs
// ----------------------------------------

using Chess2D.Piece;
using UnityEngine;

namespace Chess2D.ScriptableObjects
{
    [CreateAssetMenu(fileName = "PieceDatabase", menuName = "Custom/Piece Database")]
    public class PieceRendererDatabase : ScriptableObject
    {
        [field: SerializeField] public PieceRenderer Pawn { get; private set; }
        [field: SerializeField] public PieceRenderer Rook { get; private set; }
        [field: SerializeField] public PieceRenderer Knight { get; private set; }
        [field: SerializeField] public PieceRenderer Bishop { get; private set; }
        [field: SerializeField] public PieceRenderer Queen { get; private set; }
        [field: SerializeField] public PieceRenderer King { get; private set; }
    }
}

// ----------------------------------------

// FILE: TimerData.cs
// PATH: Assets/Scripts/TimerData.cs
// ----------------------------------------

namespace Chess2D
{
    [System.Serializable]
    public class TimerData
    {
        public float totalTime;
    }
}

// ----------------------------------------

// FILE: TurnManager.cs
// PATH: Assets/Scripts/TurnManager.cs
// ----------------------------------------

using TMPro;
using UnityEngine;

namespace Chess2D
{
    public class TurnManager : MonoBehaviour
    {
        public static TurnManager Instance { get; private set; }

        [SerializeField] private TMP_Text _turnText; // Assign in Inspector
        private bool _isPlayerTurn = true;

        private void Awake()
        {
            Instance = this;
            UpdateTurnUI();
        }

        public void SwitchTurn()
        {
            _isPlayerTurn = !_isPlayerTurn;
            UpdateTurnUI();
        }

        private void UpdateTurnUI()
        {
            _turnText.text = _isPlayerTurn ? "Your Turn" : "AI's Turn";
            _turnText.color = _isPlayerTurn ? Color.green : Color.red;
        }

        public bool IsPlayerTurn() => _isPlayerTurn;
    }
}

// ----------------------------------------

